{
  "version": 3,
  "sources": ["../node_modules/quickselect/quickselect.js", "../node_modules/rbush/index.js", "../node_modules/lineclip/index.js", "../node_modules/which-polygon/index.js", "../node_modules/wgs84/index.js", "../node_modules/@mapbox/geojson-area/index.js", "../node_modules/circle-to-polygon/index.js", "../node_modules/geojson-precision/index.js", "../node_modules/@aitodotai/json-stringify-pretty-compact/index.js", "../index.mjs", "../node_modules/@ideditor/country-coder/src/country-coder.ts", "../node_modules/polygon-clipping/node_modules/splaytree/dist/splay.esm.js", "../node_modules/polygon-clipping/dist/polygon-clipping.esm.js"],
  "sourcesContent": ["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.quickselect = factory());\n}(this, (function () { 'use strict';\n\nfunction quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nreturn quickselect;\n\n})));\n", "'use strict';\n\nmodule.exports = rbush;\nmodule.exports.default = rbush;\n\nvar quickselect = require('quickselect');\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n", "'use strict';\n\nmodule.exports = lineclip;\n\nlineclip.polyline = lineclip;\nlineclip.polygon = polygonclip;\n\n\n// Cohen-Sutherland line clippign algorithm, adapted to efficiently\n// handle polylines rather than just segments\n\nfunction lineclip(points, bbox, result) {\n\n    var len = points.length,\n        codeA = bitCode(points[0], bbox),\n        part = [],\n        i, a, b, codeB, lastCode;\n\n    if (!result) result = [];\n\n    for (i = 1; i < len; i++) {\n        a = points[i - 1];\n        b = points[i];\n        codeB = lastCode = bitCode(b, bbox);\n\n        while (true) {\n\n            if (!(codeA | codeB)) { // accept\n                part.push(a);\n\n                if (codeB !== lastCode) { // segment went outside\n                    part.push(b);\n\n                    if (i < len - 1) { // start a new line\n                        result.push(part);\n                        part = [];\n                    }\n                } else if (i === len - 1) {\n                    part.push(b);\n                }\n                break;\n\n            } else if (codeA & codeB) { // trivial reject\n                break;\n\n            } else if (codeA) { // a outside, intersect with clip edge\n                a = intersect(a, b, codeA, bbox);\n                codeA = bitCode(a, bbox);\n\n            } else { // b outside\n                b = intersect(a, b, codeB, bbox);\n                codeB = bitCode(b, bbox);\n            }\n        }\n\n        codeA = lastCode;\n    }\n\n    if (part.length) result.push(part);\n\n    return result;\n}\n\n// Sutherland-Hodgeman polygon clipping algorithm\n\nfunction polygonclip(points, bbox) {\n\n    var result, edge, prev, prevInside, i, p, inside;\n\n    // clip against each side of the clip rectangle\n    for (edge = 1; edge <= 8; edge *= 2) {\n        result = [];\n        prev = points[points.length - 1];\n        prevInside = !(bitCode(prev, bbox) & edge);\n\n        for (i = 0; i < points.length; i++) {\n            p = points[i];\n            inside = !(bitCode(p, bbox) & edge);\n\n            // if segment goes through the clip window, add an intersection\n            if (inside !== prevInside) result.push(intersect(prev, p, edge, bbox));\n\n            if (inside) result.push(p); // add a point if it's inside\n\n            prev = p;\n            prevInside = inside;\n        }\n\n        points = result;\n\n        if (!points.length) break;\n    }\n\n    return result;\n}\n\n// intersect a segment against one of the 4 lines that make up the bbox\n\nfunction intersect(a, b, edge, bbox) {\n    return edge & 8 ? [a[0] + (b[0] - a[0]) * (bbox[3] - a[1]) / (b[1] - a[1]), bbox[3]] : // top\n           edge & 4 ? [a[0] + (b[0] - a[0]) * (bbox[1] - a[1]) / (b[1] - a[1]), bbox[1]] : // bottom\n           edge & 2 ? [bbox[2], a[1] + (b[1] - a[1]) * (bbox[2] - a[0]) / (b[0] - a[0])] : // right\n           edge & 1 ? [bbox[0], a[1] + (b[1] - a[1]) * (bbox[0] - a[0]) / (b[0] - a[0])] : // left\n           null;\n}\n\n// bit code reflects the point position relative to the bbox:\n\n//         left  mid  right\n//    top  1001  1000  1010\n//    mid  0001  0000  0010\n// bottom  0101  0100  0110\n\nfunction bitCode(p, bbox) {\n    var code = 0;\n\n    if (p[0] < bbox[0]) code |= 1; // left\n    else if (p[0] > bbox[2]) code |= 2; // right\n\n    if (p[1] < bbox[1]) code |= 4; // bottom\n    else if (p[1] > bbox[3]) code |= 8; // top\n\n    return code;\n}\n", "'use strict';\n\nvar rbush = require('rbush');\nvar lineclip = require('lineclip');\n\nmodule.exports = whichPolygon;\n\nfunction whichPolygon(data) {\n    var bboxes = [];\n    for (var i = 0; i < data.features.length; i++) {\n        var feature = data.features[i];\n        var coords = feature.geometry.coordinates;\n\n        if (feature.geometry.type === 'Polygon') {\n            bboxes.push(treeItem(coords, feature.properties));\n\n        } else if (feature.geometry.type === 'MultiPolygon') {\n            for (var j = 0; j < coords.length; j++) {\n                bboxes.push(treeItem(coords[j], feature.properties));\n            }\n        }\n    }\n\n    var tree = rbush().load(bboxes);\n\n    function query(p, multi) {\n        var output = [],\n            result = tree.search({\n                minX: p[0],\n                minY: p[1],\n                maxX: p[0],\n                maxY: p[1]\n            });\n        for (var i = 0; i < result.length; i++) {\n            if (insidePolygon(result[i].coords, p)) {\n                if (multi)\n                    output.push(result[i].props);\n                else\n                    return result[i].props;\n            }\n        }\n        return multi && output.length ? output : null;\n    }\n\n    query.tree = tree;\n    query.bbox = function queryBBox(bbox) {\n        var output = [];\n        var result = tree.search({\n            minX: bbox[0],\n            minY: bbox[1],\n            maxX: bbox[2],\n            maxY: bbox[3]\n        });\n        for (var i = 0; i < result.length; i++) {\n            if (polygonIntersectsBBox(result[i].coords, bbox)) {\n                output.push(result[i].props);\n            }\n        }\n        return output;\n    };\n\n    return query;\n}\n\nfunction polygonIntersectsBBox(polygon, bbox) {\n    var bboxCenter = [\n        (bbox[0] + bbox[2]) / 2,\n        (bbox[1] + bbox[3]) / 2\n    ];\n    if (insidePolygon(polygon, bboxCenter)) return true;\n    for (var i = 0; i < polygon.length; i++) {\n        if (lineclip(polygon[i], bbox).length > 0) return true;\n    }\n    return false;\n}\n\n// ray casting algorithm for detecting if point is in polygon\nfunction insidePolygon(rings, p) {\n    var inside = false;\n    for (var i = 0, len = rings.length; i < len; i++) {\n        var ring = rings[i];\n        for (var j = 0, len2 = ring.length, k = len2 - 1; j < len2; k = j++) {\n            if (rayIntersect(p, ring[j], ring[k])) inside = !inside;\n        }\n    }\n    return inside;\n}\n\nfunction rayIntersect(p, p1, p2) {\n    return ((p1[1] > p[1]) !== (p2[1] > p[1])) && (p[0] < (p2[0] - p1[0]) * (p[1] - p1[1]) / (p2[1] - p1[1]) + p1[0]);\n}\n\nfunction treeItem(coords, props) {\n    var item = {\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity,\n        coords: coords,\n        props: props\n    };\n\n    for (var i = 0; i < coords[0].length; i++) {\n        var p = coords[0][i];\n        item.minX = Math.min(item.minX, p[0]);\n        item.minY = Math.min(item.minY, p[1]);\n        item.maxX = Math.max(item.maxX, p[0]);\n        item.maxY = Math.max(item.maxY, p[1]);\n    }\n    return item;\n}\n", "module.exports.RADIUS = 6378137;\nmodule.exports.FLATTENING = 1/298.257223563;\nmodule.exports.POLAR_RADIUS = 6356752.3142;\n", "var wgs84 = require('wgs84');\n\nmodule.exports.geometry = geometry;\nmodule.exports.ring = ringArea;\n\nfunction geometry(_) {\n    var area = 0, i;\n    switch (_.type) {\n        case 'Polygon':\n            return polygonArea(_.coordinates);\n        case 'MultiPolygon':\n            for (i = 0; i < _.coordinates.length; i++) {\n                area += polygonArea(_.coordinates[i]);\n            }\n            return area;\n        case 'Point':\n        case 'MultiPoint':\n        case 'LineString':\n        case 'MultiLineString':\n            return 0;\n        case 'GeometryCollection':\n            for (i = 0; i < _.geometries.length; i++) {\n                area += geometry(_.geometries[i]);\n            }\n            return area;\n    }\n}\n\nfunction polygonArea(coords) {\n    var area = 0;\n    if (coords && coords.length > 0) {\n        area += Math.abs(ringArea(coords[0]));\n        for (var i = 1; i < coords.length; i++) {\n            area -= Math.abs(ringArea(coords[i]));\n        }\n    }\n    return area;\n}\n\n/**\n * Calculate the approximate area of the polygon were it projected onto\n *     the earth.  Note that this area will be positive if ring is oriented\n *     clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n *     Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n *\n * Returns:\n * {float} The approximate signed geodesic area of the polygon in square\n *     meters.\n */\n\nfunction ringArea(coords) {\n    var p1, p2, p3, lowerIndex, middleIndex, upperIndex, i,\n    area = 0,\n    coordsLength = coords.length;\n\n    if (coordsLength > 2) {\n        for (i = 0; i < coordsLength; i++) {\n            if (i === coordsLength - 2) {// i = N-2\n                lowerIndex = coordsLength - 2;\n                middleIndex = coordsLength -1;\n                upperIndex = 0;\n            } else if (i === coordsLength - 1) {// i = N-1\n                lowerIndex = coordsLength - 1;\n                middleIndex = 0;\n                upperIndex = 1;\n            } else { // i = 0 to N-3\n                lowerIndex = i;\n                middleIndex = i+1;\n                upperIndex = i+2;\n            }\n            p1 = coords[lowerIndex];\n            p2 = coords[middleIndex];\n            p3 = coords[upperIndex];\n            area += ( rad(p3[0]) - rad(p1[0]) ) * Math.sin( rad(p2[1]));\n        }\n\n        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;\n    }\n\n    return area;\n}\n\nfunction rad(_) {\n    return _ * Math.PI / 180;\n}", "\"use strict\";\nfunction toRadians(angleInDegrees) {\n  return (angleInDegrees * Math.PI) / 180;\n}\n\nfunction toDegrees(angleInRadians) {\n  return (angleInRadians * 180) / Math.PI;\n}\n\nfunction offset(c1, distance, bearing) {\n  var lat1 = toRadians(c1[1]);\n  var lon1 = toRadians(c1[0]);\n  var dByR = distance / 6378137; // distance divided by 6378137 (radius of the earth) wgs84\n  var lat = Math.asin(\n    Math.sin(lat1) * Math.cos(dByR) +\n      Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing)\n  );\n  var lon =\n    lon1 +\n    Math.atan2(\n      Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),\n      Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat)\n    );\n  return [toDegrees(lon), toDegrees(lat)];\n}\n\nfunction validateCenter(center) {\n  const validCenterLengths = [2, 3];\n  if (!Array.isArray(center) || !validCenterLengths.includes(center.length)) {\n    throw new Error(\"ERROR! Center has to be an array of length two or three\");\n  }\n  const [lng, lat] = center;\n  if (typeof lng !== \"number\" || typeof lat !== \"number\") {\n    throw new Error(\n      `ERROR! Longitude and Latitude has to be numbers but where ${typeof lng} and ${typeof lat}`\n    );\n  }\n  if (lng > 180 || lng < -180) {\n    throw new Error(\n      `ERROR! Longitude has to be between -180 and 180 but was ${lng}`\n    );\n  }\n\n  if (lat > 90 || lat < -90) {\n    throw new Error(\n      `ERROR! Latitude has to be between -90 and 90 but was ${lat}`\n    );\n  }\n}\n\nfunction validateRadius(radius) {\n  if (typeof radius !== \"number\") {\n    throw new Error(\n      `ERROR! Radius has to be a positive number but was: ${typeof radius}`\n    );\n  }\n\n  if (radius <= 0) {\n    throw new Error(\n      `ERROR! Radius has to be a positive number but was: ${radius}`\n    );\n  }\n}\n\nfunction validateNumberOfSegments(numberOfSegments) {\n  if (typeof numberOfSegments !== \"number\" && numberOfSegments !== undefined) {\n    throw new Error(\n      `ERROR! Number of segments has to be a number but was: ${typeof numberOfSegments}`\n    );\n  }\n\n  if (numberOfSegments < 3) {\n    throw new Error(\n      `ERROR! Number of segments has to be at least 3 but was: ${numberOfSegments}`\n    );\n  }\n}\n\nfunction validateInput({ center, radius, numberOfSegments }) {\n  validateCenter(center);\n  validateRadius(radius);\n  validateNumberOfSegments(numberOfSegments);\n}\n\nmodule.exports = function circleToPolygon(center, radius, numberOfSegments) {\n  var n = numberOfSegments ? numberOfSegments : 32;\n\n  // validateInput() throws error on invalid input and do nothing on valid input\n  validateInput({ center, radius, numberOfSegments });\n\n  var coordinates = [];\n  for (var i = 0; i < n; ++i) {\n    coordinates.push(offset(center, radius, (2 * Math.PI * -i) / n));\n  }\n  coordinates.push(coordinates[0]);\n\n  return {\n    type: \"Polygon\",\n    coordinates: [coordinates]\n  };\n};\n", "(function() {\n\n  function parse(t, coordinatePrecision, extrasPrecision) {\n\n    function point(p) {\n      return p.map(function(e, index) {\n        if (index < 2) {\n            return 1 * e.toFixed(coordinatePrecision);\n        } else {\n            return 1 * e.toFixed(extrasPrecision);\n        }\n      });\n    }\n\n    function multi(l) {\n      return l.map(point);\n    }\n\n    function poly(p) {\n      return p.map(multi);\n    }\n\n    function multiPoly(m) {\n      return m.map(poly);\n    }\n\n    function geometry(obj) {\n      if (!obj) {\n        return {};\n      }\n      \n      switch (obj.type) {\n        case \"Point\":\n          obj.coordinates = point(obj.coordinates);\n          return obj;\n        case \"LineString\":\n        case \"MultiPoint\":\n          obj.coordinates = multi(obj.coordinates);\n          return obj;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          obj.coordinates = poly(obj.coordinates);\n          return obj;\n        case \"MultiPolygon\":\n          obj.coordinates = multiPoly(obj.coordinates);\n          return obj;\n        case \"GeometryCollection\":\n          obj.geometries = obj.geometries.map(geometry);\n          return obj;\n        default :\n          return {};\n      }\n    }\n\n    function feature(obj) {\n      obj.geometry = geometry(obj.geometry);\n      return obj\n    }\n\n    function featureCollection(f) {\n      f.features = f.features.map(feature);\n      return f;\n    }\n\n    function geometryCollection(g) {\n      g.geometries = g.geometries.map(geometry);\n      return g;\n    }\n\n    if (!t) {\n      return t;\n    }\n\n    switch (t.type) {\n      case \"Feature\":\n        return feature(t);\n      case \"GeometryCollection\" :\n        return geometryCollection(t);\n      case \"FeatureCollection\" :\n        return featureCollection(t);\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n      case \"MultiPoint\":\n      case \"MultiPolygon\":\n      case \"MultiLineString\":\n        return geometry(t);\n      default :\n        return t;\n    }\n      \n  }\n\n  module.exports = parse;\n  module.exports.parse = parse;\n\n}());\n  \n", "function isObject (obj) {\n  return typeof obj === 'object' && obj !== null\n}\n\nfunction forEach (obj, cb) {\n  if (Array.isArray(obj)) {\n    obj.forEach(cb)\n  } else if (isObject(obj)) {\n    Object.keys(obj).forEach(function (key) {\n      var val = obj[key]\n      cb(val, key)\n    })\n  }\n}\n\nfunction getTreeDepth (obj) {\n  var depth = 0\n\n  if (Array.isArray(obj) || isObject(obj)) {\n    forEach(obj, function (val) {\n      if (Array.isArray(val) || isObject(val)) {\n        var tmpDepth = getTreeDepth(val)\n        if (tmpDepth > depth) {\n          depth = tmpDepth\n        }\n      }\n    })\n\n    return depth + 1\n  }\n\n  return depth\n}\n\nfunction stringify (obj, options) {\n  options = options || {}\n  var indent = JSON.stringify([1], null, get(options, 'indent', 2)).slice(2, -3)\n  var addMargin = get(options, 'margins', false)\n  var addArrayMargin = get(options, 'arrayMargins', false)\n  var addObjectMargin = get(options, 'objectMargins', false)\n  var maxLength = (indent === '' ? Infinity : get(options, 'maxLength', 80))\n  var maxNesting = get(options, 'maxNesting', Infinity)\n\n  return (function _stringify (obj, currentIndent, reserved) {\n    if (obj && typeof obj.toJSON === 'function') {\n      obj = obj.toJSON()\n    }\n\n    var string = JSON.stringify(obj)\n\n    if (string === undefined) {\n      return string\n    }\n\n    var length = maxLength - currentIndent.length - reserved\n\n    var treeDepth = getTreeDepth(obj)\n    if (treeDepth <= maxNesting && string.length <= length) {\n      var prettified = prettify(string, {\n        addMargin: addMargin,\n        addArrayMargin: addArrayMargin,\n        addObjectMargin: addObjectMargin\n      })\n      if (prettified.length <= length) {\n        return prettified\n      }\n    }\n\n    if (isObject(obj)) {\n      var nextIndent = currentIndent + indent\n      var items = []\n      var delimiters\n      var comma = function (array, index) {\n        return (index === array.length - 1 ? 0 : 1)\n      }\n\n      if (Array.isArray(obj)) {\n        for (var index = 0; index < obj.length; index++) {\n          items.push(\n            _stringify(obj[index], nextIndent, comma(obj, index)) || 'null'\n          )\n        }\n        delimiters = '[]'\n      } else {\n        Object.keys(obj).forEach(function (key, index, array) {\n          var keyPart = JSON.stringify(key) + ': '\n          var value = _stringify(obj[key], nextIndent,\n                                 keyPart.length + comma(array, index))\n          if (value !== undefined) {\n            items.push(keyPart + value)\n          }\n        })\n        delimiters = '{}'\n      }\n\n      if (items.length > 0) {\n        return [\n          delimiters[0],\n          indent + items.join(',\\n' + nextIndent),\n          delimiters[1]\n        ].join('\\n' + currentIndent)\n      }\n    }\n\n    return string\n  }(obj, '', 0))\n}\n\n// Note: This regex matches even invalid JSON strings, but since we\u2019re\n// working on the output of `JSON.stringify` we know that only valid strings\n// are present (unless the user supplied a weird `options.indent` but in\n// that case we don\u2019t care since the output would be invalid anyway).\nvar stringOrChar = /(\"(?:[^\\\\\"]|\\\\.)*\")|[:,\\][}{]/g\n\nfunction prettify (string, options) {\n  options = options || {}\n\n  var tokens = {\n    '{': '{',\n    '}': '}',\n    '[': '[',\n    ']': ']',\n    ',': ', ',\n    ':': ': '\n  }\n\n  if (options.addMargin || options.addObjectMargin) {\n    tokens['{'] = '{ '\n    tokens['}'] = ' }'\n  }\n\n  if (options.addMargin || options.addArrayMargin) {\n    tokens['['] = '[ '\n    tokens[']'] = ' ]'\n  }\n\n  return string.replace(stringOrChar, function (match, string) {\n    return string ? match : tokens[match]\n  })\n}\n\nfunction get (options, name, defaultValue) {\n  return (name in options ? options[name] : defaultValue)\n}\n\nmodule.exports = stringify\n", "import * as CountryCoder from '@ideditor/country-coder';\n\nimport calcArea from '@mapbox/geojson-area';\nimport circleToPolygon  from 'circle-to-polygon';\nimport polygonClipping from 'polygon-clipping';\nimport precision  from 'geojson-precision';\nimport prettyStringify from '@aitodotai/json-stringify-pretty-compact';\n\n\nexport class LocationConflation {\n\n  // constructor\n  //\n  // `fc`  Optional FeatureCollection of known features\n  //\n  // Optionally pass a GeoJSON FeatureCollection of known features which we can refer to later.\n  // Each feature must have a filename-like `id`, for example: `something.geojson`\n  //\n  // {\n  //   \"type\": \"FeatureCollection\"\n  //   \"features\": [\n  //     {\n  //       \"type\": \"Feature\",\n  //       \"id\": \"philly_metro.geojson\",\n  //       \"properties\": { \u2026 },\n  //       \"geometry\": { \u2026 }\n  //     }\n  //   ]\n  // }\n  constructor(fc) {\n    // The _cache retains resolved features, so if you ask for the same thing multiple times\n    // we don't repeat the expensive resolving/clipping operations.\n    //\n    // Each feature has a stable identifier that is used as the cache key.\n    // The identifiers look like:\n    // - for point locations, the stringified point:          e.g. '[8.67039,49.41882]'\n    // - for geojson locations, the geojson id:               e.g. 'de-hamburg.geojson'\n    // - for countrycoder locations, feature.id property:     e.g. 'Q2'  (countrycoder uses Wikidata identifiers)\n    // - for aggregated locationSets, +[include]-[exclude]:   e.g '+[Q2]-[Q18,Q27611]'\n    this._cache = {};\n\n    // When strict mode = true, throw on invalid locations or locationSets.\n    // When strict mode = false, return `null` for invalid locations or locationSets.\n    this._strict = true;\n\n    // process input FeatureCollection\n    if (fc && fc.type === 'FeatureCollection' && Array.isArray(fc.features)) {\n      fc.features.forEach(feature => {\n        feature.properties = feature.properties || {};\n        let props = feature.properties;\n\n        // Get `id` from either `id` or `properties`\n        let id = feature.id || props.id;\n        if (!id || !/^\\S+\\.geojson$/i.test(id)) return;\n\n        // Ensure `id` exists and is lowercase\n        id = id.toLowerCase();\n        feature.id = id;\n        props.id = id;\n\n        // Ensure `area` property exists\n        if (!props.area) {\n          const area = calcArea.geometry(feature.geometry) / 1e6;  // m\u00B2 to km\u00B2\n          props.area = Number(area.toFixed(2));\n        }\n\n        this._cache[id] = feature;\n      });\n    }\n\n    // Replace CountryCoder world geometry to be a polygon covering the world.\n    let world = _cloneDeep(CountryCoder.feature('Q2'));\n    world.geometry = {\n      type: 'Polygon',\n      coordinates: [[[-180, -90], [180, -90], [180, 90], [-180, 90], [-180, -90]]]\n    };\n    world.id = 'Q2';\n    world.properties.id = 'Q2';\n    world.properties.area = calcArea.geometry(world.geometry) / 1e6;  // m\u00B2 to km\u00B2\n    this._cache.Q2 = world;\n  }\n\n\n  // validateLocation\n  // `location`  The location to validate\n  //\n  // Pass a `location` value to validate\n  //\n  // Returns a result like:\n  //   {\n  //     type:     'point', 'geojson', or 'countrycoder'\n  //     location:  the queried location\n  //     id:        the stable identifier for the feature\n  //   }\n  // or `null` if the location is invalid\n  //\n  validateLocation(location) {\n    if (Array.isArray(location) && (location.length === 2 || location.length === 3)) {   // [lon, lat] or [lon, lat, radius] point?\n      const lon = location[0];\n      const lat = location[1];\n      const radius = location[2];\n      if (\n        Number.isFinite(lon) && lon >= -180 && lon <= 180 &&\n        Number.isFinite(lat) && lat >= -90 && lat <= 90 &&\n        (location.length === 2 || (Number.isFinite(radius) && radius > 0))\n      ) {\n        const id = '[' + location.toString() + ']';\n        return { type: 'point', location: location, id: id };\n      }\n\n    } else if (typeof location === 'string' && /^\\S+\\.geojson$/i.test(location)) {   // a .geojson filename?\n      const id = location.toLowerCase();\n      if (this._cache[id]) {\n        return { type: 'geojson', location: location, id: id };\n      }\n\n    } else if (typeof location === 'string' || typeof location === 'number') {   // a country-coder value?\n      const feature = CountryCoder.feature(location);\n      if (feature) {\n        // Use wikidata QID as the identifier, since that seems to be the one\n        // property that everything in CountryCoder is guaranteed to have.\n        const id = feature.properties.wikidata;\n        return { type: 'countrycoder', location: location, id: id };\n      }\n    }\n\n    if (this._strict) {\n      throw new Error(`validateLocation:  Invalid location: \"${location}\".`);\n    } else {\n      return null;\n    }\n  }\n\n\n  // resolveLocation\n  // `location`  The location to resolve\n  //\n  // Pass a `location` value to resolve\n  //\n  // Returns a result like:\n  //   {\n  //     type:      'point', 'geojson', or 'countrycoder'\n  //     location:  the queried location\n  //     id:        a stable identifier for the feature\n  //     feature:   the resolved GeoJSON feature\n  //   }\n  //  or `null` if the location is invalid\n  //\n  resolveLocation(location) {\n    const valid = this.validateLocation(location);\n    if (!valid) return null;\n\n    const id = valid.id;\n\n    // Return a result from cache if we can\n    if (this._cache[id]) {\n      return Object.assign(valid, { feature: this._cache[id] });\n    }\n\n    // A [lon,lat] coordinate pair?\n    if (valid.type === 'point') {\n      const lon = location[0];\n      const lat = location[1];\n      const radius = location[2] || 25;   // km\n      const EDGES = 10;\n      const PRECISION = 3;\n      const area = Math.PI * radius * radius;\n      const feature = this._cache[id] = precision({\n        type: 'Feature',\n        id: id,\n        properties: { id: id, area: Number(area.toFixed(2)) },\n        geometry: circleToPolygon([lon, lat], radius * 1000, EDGES)  // km to m\n      }, PRECISION);\n      return Object.assign(valid, { feature: feature });\n\n    // A .geojson filename?\n    } else if (valid.type === 'geojson') {\n      // nothing to do here - these are all in _cache and would have returned already\n\n    // A country-coder identifier?\n    } else if (valid.type === 'countrycoder') {\n      let feature = _cloneDeep(CountryCoder.feature(id));\n      let props = feature.properties;\n\n      // -> This block of code is weird and requires some explanation. <-\n      // CountryCoder includes higher level features which are made up of members.\n      // These features don't have their own geometry, but CountryCoder provides an\n      //   `aggregateFeature` method to combine these members into a MultiPolygon.\n      // In the past, Turf/JSTS/martinez could not handle the aggregated features,\n      //   so we'd iteratively union them all together.  (this was slow)\n      // But now mfogel/polygon-clipping handles these MultiPolygons like a boss.\n      // This approach also has the benefit of removing all the internal boaders and\n      //   simplifying the regional polygons a lot.\n      if (Array.isArray(props.members)) {\n        let aggregate = CountryCoder.aggregateFeature(id);\n        aggregate.geometry.coordinates = _clip([aggregate], 'UNION').geometry.coordinates;\n        feature.geometry = aggregate.geometry;\n      }\n\n      // Ensure `area` property exists\n      if (!props.area) {\n        const area = calcArea.geometry(feature.geometry) / 1e6;  // m\u00B2 to km\u00B2\n        props.area = Number(area.toFixed(2));\n      }\n\n      // Ensure `id` property exists\n      feature.id = id;\n      props.id = id;\n\n      this._cache[id] = feature;\n      return Object.assign(valid, { feature: feature });\n    }\n\n    if (this._strict) {\n      throw new Error(`resolveLocation:  Couldn't resolve location \"${location}\".`);\n    } else {\n      return null;\n    }\n  }\n\n\n  // validateLocationSet\n  // `locationSet`  the locationSet to validate\n  //\n  // Pass a locationSet Object to validate like:\n  //   {\n  //     include: [ Array of locations ],\n  //     exclude: [ Array of locations ]\n  //   }\n  //\n  // Returns a result like:\n  //   {\n  //     type:         'locationset'\n  //     locationSet:  the queried locationSet\n  //     id:           the stable identifier for the feature\n  //   }\n  // or `null` if the locationSet is invalid\n  //\n  validateLocationSet(locationSet) {\n    locationSet = locationSet || {};\n    const validator = this.validateLocation.bind(this);\n    let include = (locationSet.include || []).map(validator).filter(Boolean);\n    let exclude = (locationSet.exclude || []).map(validator).filter(Boolean);\n\n    if (!include.length) {\n      if (this._strict) {\n        throw new Error(`validateLocationSet:  LocationSet includes nothing.`);\n      } else {\n        // non-strict mode, replace an empty locationSet with one that includes \"the world\"\n        locationSet.include = ['Q2'];\n        include = [{ type: 'countrycoder', location: 'Q2', id: 'Q2' }];\n      }\n    }\n\n    // Generate stable identifier\n    include.sort(_sortLocations);\n    let id = '+[' + include.map(d => d.id).join(',') + ']';\n    if (exclude.length) {\n      exclude.sort(_sortLocations);\n      id += '-[' + exclude.map(d => d.id).join(',') + ']';\n    }\n\n    return { type: 'locationset', locationSet: locationSet, id: id };\n  }\n\n\n  // resolveLocationSet\n  // `locationSet`  the locationSet to resolve\n  //\n  // Pass a locationSet Object to validate like:\n  //   {\n  //     include: [ Array of locations ],\n  //     exclude: [ Array of locations ]\n  //   }\n  //\n  // Returns a result like:\n  //   {\n  //     type:         'locationset'\n  //     locationSet:  the queried locationSet\n  //     id:           the stable identifier for the feature\n  //     feature:      the resolved GeoJSON feature\n  //   }\n  // or `null` if the locationSet is invalid\n  //\n  resolveLocationSet(locationSet) {\n    locationSet = locationSet || {};\n    const valid = this.validateLocationSet(locationSet);\n    if (!valid) return null;\n\n    const id = valid.id;\n\n    // Return a result from cache if we can\n    if (this._cache[id]) {\n      return Object.assign(valid, { feature: this._cache[id] });\n    }\n\n    const resolver = this.resolveLocation.bind(this);\n    const includes = (locationSet.include || []).map(resolver).filter(Boolean);\n    const excludes = (locationSet.exclude || []).map(resolver).filter(Boolean);\n\n    // Return quickly if it's a single included location..\n    if (includes.length === 1 && excludes.length === 0) {\n      return Object.assign(valid, { feature: includes[0].feature });\n    }\n\n    // Calculate unions\n    const includeGeoJSON = _clip(includes.map(d => d.feature), 'UNION');\n    const excludeGeoJSON = _clip(excludes.map(d => d.feature), 'UNION');\n\n    // Calculate difference, update `area` and return result\n    let resultGeoJSON = excludeGeoJSON ? _clip([includeGeoJSON, excludeGeoJSON], 'DIFFERENCE') : includeGeoJSON;\n    const area = calcArea.geometry(resultGeoJSON.geometry) / 1e6;  // m\u00B2 to km\u00B2\n    resultGeoJSON.id = id;\n    resultGeoJSON.properties = { id: id, area: Number(area.toFixed(2)) };\n\n    this._cache[id] = resultGeoJSON;\n    return Object.assign(valid, { feature: resultGeoJSON });\n  }\n\n\n  // strict\n  //\n  strict(val) {\n    if (val === undefined) {   // get\n      return this._strict;\n    } else {                   // set\n      this._strict = val;\n      return this;\n    }\n  }\n\n\n  // cache\n  // convenience method to access the internal cache\n  cache() {\n    return this._cache;\n  }\n\n\n  // stringify\n  // convenience method to prettyStringify the given object\n  stringify(obj, options) {\n    return prettyStringify(obj, options);\n  }\n}\n\n\n// Wrap the mfogel/polygon-clipping library and return a GeoJSON feature.\nfunction _clip(features, which) {\n  if (!Array.isArray(features) || !features.length) return null;\n\n  const fn = { UNION: polygonClipping.union, DIFFERENCE: polygonClipping.difference }[which];\n  const args = features.map(feature => feature.geometry.coordinates);\n  const coords = fn.apply(null, args);\n  return {\n    type: 'Feature',\n    properties: {},\n    geometry: {\n      type: whichType(coords),\n      coordinates: coords\n    }\n  };\n\n  // is this a Polygon or a MultiPolygon?\n  function whichType(coords) {\n    const a = Array.isArray(coords);\n    const b = a && Array.isArray(coords[0]);\n    const c = b && Array.isArray(coords[0][0]);\n    const d = c && Array.isArray(coords[0][0][0]);\n    return d ? 'MultiPolygon' : 'Polygon';\n  }\n}\n\n\nfunction _cloneDeep(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\n\n// Sorting the location lists is ok because they end up unioned together.\n// This sorting makes it possible to generate a deterministic id.\nfunction _sortLocations(a, b) {\n  const rank = { countrycoder: 1, geojson: 2, point: 3 };\n  const aRank = rank[a.type];\n  const bRank = rank[b.type];\n\n  return (aRank > bRank) ? 1\n    : (aRank < bRank) ? -1\n    : a.id.localeCompare(b.id);\n}\n", "import whichPolygon from 'which-polygon';\nimport rawBorders from './data/borders.json';\n\ntype RegionFeatureProperties = {\n  // Unique identifier specific to country-coder\n  id: string;\n\n  // ISO 3166-1 alpha-2 code\n  iso1A2: string | undefined;\n\n  // ISO 3166-1 alpha-3 code\n  iso1A3: string | undefined;\n\n  // ISO 3166-1 numeric-3 code\n  iso1N3: string | undefined;\n\n  // UN M49 code\n  m49: string | undefined;\n\n  // Wikidata QID\n  wikidata: string;\n\n  // The emoji flag sequence derived from this feature's ISO 3166-1 alpha-2 code\n  emojiFlag: string | undefined;\n\n  // The ccTLD (country code top-level domain)\n  ccTLD: string | undefined;\n\n  // The common English name\n  nameEn: string;\n\n  // Additional identifiers which can be used to look up this feature;\n  // these cannot collide with the identifiers for any other feature\n  aliases: Array<string> | undefined;\n\n  // For features entirely within a country, the ISO 3166-1 alpha-2 code for that country\n  country: string | undefined;\n\n  // The ISO 3166-1 alpha-2, M49, or QIDs of other features this feature is entirely within, including its country\n  groups: Array<string>;\n\n  // The ISO 3166-1 alpha-2, M49, or QIDs of other features this feature contains;\n  // the inverse of `groups`\n  members: Array<string> | undefined;\n\n  // The rough geographic type of this feature.\n  // Levels do not necessarily nest cleanly within each other.\n  // - `world`: all features\n\n  // - `unitedNations`: United Nations\n  // - `union`: European Union\n  // - `subunion`: Outermost Regions of the EU, Overseas Countries and Territories of the EU\n\n  // Defined by the UN\n  // - `region`: Africa, Americas, Antarctica, Asia, Europe, Oceania\n  // - `subregion`: Sub-Saharan Africa, North America, Micronesia, etc.\n  // - `intermediateRegion`: Eastern Africa, South America, Channel Islands, etc.\n\n  // - `sharedLandform`: Great Britain, Macaronesia, Mariana Islands, etc.\n  // - `country`: Ethiopia, Brazil, United States, etc.\n  // - `subcountryGroup`\n  // - `territory`: Puerto Rico, Gurnsey, Hong Kong, etc.\n  // - `subterritory`: Sark, Ascension Island, Diego Garcia, etc.\n  level: string;\n\n  // The status of this feature's ISO 3166-1 code(s), if any\n  // - `official`: officially-assigned\n  // - `excRes`: exceptionally-reserved\n  // - `usrAssn`: user-assigned\n  isoStatus: string | undefined;\n\n  // The side of the road that traffic drives on within this feature\n  // - `right`\n  // - `left`\n  driveSide: string | undefined;\n\n  // The unit used for road traffic speeds within this feature\n  // - `mph`: miles per hour\n  // - `km/h`: kilometers per hour\n  roadSpeedUnit: string | undefined;\n\n  // The unit used for road vehicle height restrictions within this feature\n  // - `ft`: feet and inches\n  // - `m`: meters\n  roadHeightUnit: string | undefined;\n\n  // The international calling codes for this feature, sometimes including area codes\n  // e.g. `1`, `1 340`\n  callingCodes: Array<string> | undefined;\n};\ntype RegionFeature = { type: string; geometry: any; properties: RegionFeatureProperties };\ntype RegionFeatureCollection = { type: string; features: Array<RegionFeature> };\ntype Vec2 = [number, number]; // [lon, lat]\ntype Bbox = [number, number, number, number]; // [minLon, minLat, maxLon, maxLat]\ntype PointGeometry = { type: string; coordinates: Vec2 };\ntype PointFeature = { type: string; geometry: PointGeometry; properties: any };\ntype Location = Vec2 | PointGeometry | PointFeature;\ntype CodingOptions = {\n  // For overlapping features, the division level of the one to get. If no feature\n  // exists at the given level, the feature at the next higher level is returned.\n  // See the `level` property of `RegionFeatureProperties` for possible values.\n  level?: string | undefined;\n  // Only a feature at the specified level or lower will be returned.\n  maxLevel?: string | undefined;\n  // Only a feature with the specified property will be returned.\n  withProp?: string | undefined;\n};\n\n// The base GeoJSON feature collection\nexport let borders: RegionFeatureCollection = <RegionFeatureCollection>rawBorders;\n\n// The whichPolygon interface for looking up a feature by point\nlet whichPolygonGetter: any = {};\n// The cache for looking up a feature by identifier\nlet featuresByCode: any = {};\n\n// discard special characters and instances of and/the/of that aren't the only characters\nlet idFilterRegex = /(?=(?!^(and|the|of|el|la|de)$))(\\b(and|the|of|el|la|de)\\b)|[-_ .,'()&[\\]/]/gi;\n\nfunction canonicalID(id: string | null): string {\n  let s = id || '';\n  if (s.charAt(0) === '.') {\n    // skip replace if it leads with a '.' (e.g. a ccTLD like '.de', '.la')\n    return s.toUpperCase();\n  } else {\n    return s.replace(idFilterRegex, '').toUpperCase();\n  }\n}\n\n// Geographic levels, roughly from most to least granular\nlet levels = [\n  'subterritory',\n  'territory',\n  'subcountryGroup',\n  'country',\n  'sharedLandform',\n  'intermediateRegion',\n  'subregion',\n  'region',\n  'subunion',\n  'union',\n  'unitedNations',\n  'world'\n];\n\nloadDerivedDataAndCaches(borders);\n// Loads implicit feature data and the getter index caches\nfunction loadDerivedDataAndCaches(borders) {\n  let identifierProps = ['iso1A2', 'iso1A3', 'm49', 'wikidata', 'emojiFlag', 'ccTLD', 'nameEn'];\n  let geometryFeatures: Array<RegionFeature> = [];\n\n  for (let i in borders.features) {\n    let feature = borders.features[i];\n\n    // generate a unique ID for each feature\n    feature.properties.id =\n      feature.properties.iso1A2 || feature.properties.m49 || feature.properties.wikidata;\n\n    loadM49(feature);\n    loadTLD(feature);\n    loadIsoStatus(feature);\n    loadLevel(feature);\n    loadGroups(feature);\n    loadFlag(feature);\n\n    // cache only after loading derived IDs\n    cacheFeatureByIDs(feature);\n\n    if (feature.geometry) geometryFeatures.push(feature);\n  }\n\n  // must load `members` only after fully loading `featuresByID`\n  for (let i in borders.features) {\n    let feature = borders.features[i];\n    // ensure all groups are listed by their ID\n    feature.properties.groups = feature.properties.groups.map(function (groupID) {\n      return featuresByCode[groupID].properties.id;\n    });\n\n    loadMembersForGroupsOf(feature);\n  }\n\n  for (let i in borders.features) {\n    let feature = borders.features[i];\n\n    // must load attributes only after loading geometry features into `members`\n    loadRoadSpeedUnit(feature);\n    loadRoadHeightUnit(feature);\n    loadDriveSide(feature);\n    loadCallingCodes(feature);\n\n    loadGroupGroups(feature);\n  }\n\n  for (let i in borders.features) {\n    let feature = borders.features[i];\n    // order groups by their `level`\n    feature.properties.groups.sort(function (groupID1, groupID2) {\n      return (\n        levels.indexOf(featuresByCode[groupID1].properties.level) -\n        levels.indexOf(featuresByCode[groupID2].properties.level)\n      );\n    });\n    // order members by their `level` and then by order in borders\n    if (feature.properties.members)\n      feature.properties.members.sort(function (id1, id2) {\n        let diff =\n          levels.indexOf(featuresByCode[id1].properties.level) -\n          levels.indexOf(featuresByCode[id2].properties.level);\n        if (diff === 0) {\n          return (\n            borders.features.indexOf(featuresByCode[id1]) -\n            borders.features.indexOf(featuresByCode[id2])\n          );\n        }\n        return diff;\n      });\n  }\n\n  // whichPolygon doesn't support null geometry even though GeoJSON does\n  let geometryOnlyCollection: RegionFeatureCollection = {\n    type: 'FeatureCollection',\n    features: geometryFeatures\n  };\n  whichPolygonGetter = whichPolygon(geometryOnlyCollection);\n\n  function loadGroups(feature: RegionFeature) {\n    let props = feature.properties;\n    if (!props.groups) {\n      props.groups = [];\n    }\n    if (feature.geometry && props.country) {\n      // Add `country` to `groups`\n      props.groups.push(props.country);\n    }\n    if (props.m49 !== '001') {\n      // all features are in the world feature except the world itself\n      props.groups.push('001');\n    }\n  }\n\n  function loadM49(feature: RegionFeature) {\n    let props = feature.properties;\n    if (!props.m49 && props.iso1N3) {\n      // M49 is a superset of ISO numerics so we only need to store one\n      props.m49 = props.iso1N3;\n    }\n  }\n\n  function loadTLD(feature: RegionFeature) {\n    let props = feature.properties;\n    if (props.level === 'unitedNations') return; // `.un` is not a ccTLD\n    if (!props.ccTLD && props.iso1A2) {\n      // ccTLD is nearly the same as iso1A2, so we only need to explicitly code any exceptions\n      props.ccTLD = '.' + props.iso1A2.toLowerCase();\n    }\n  }\n\n  function loadIsoStatus(feature: RegionFeature) {\n    let props = feature.properties;\n    if (!props.isoStatus && props.iso1A2) {\n      // Features with an ISO code but no explicit status are officially-assigned\n      props.isoStatus = 'official';\n    }\n  }\n\n  function loadLevel(feature: RegionFeature) {\n    let props = feature.properties;\n    if (props.level) return;\n    if (!props.country) {\n      // a feature without an explicit `level` or `country` is itself a country\n      props.level = 'country';\n    } else if (!props.iso1A2 || props.isoStatus === 'official') {\n      props.level = 'territory';\n    } else {\n      props.level = 'subterritory';\n    }\n  }\n\n  function loadGroupGroups(feature: RegionFeature) {\n    let props = feature.properties;\n    if (feature.geometry || !props.members) return;\n    let featureLevelIndex = levels.indexOf(props.level);\n    let sharedGroups: Array<string> = [];\n    for (let i in props.members) {\n      let memberID = props.members[i];\n      let member = featuresByCode[memberID];\n      let memberGroups = member.properties.groups.filter(function (groupID) {\n        return (\n          groupID !== feature.properties.id &&\n          featureLevelIndex < levels.indexOf(featuresByCode[groupID].properties.level)\n        );\n      });\n      if (i === '0') {\n        sharedGroups = memberGroups;\n      } else {\n        sharedGroups = sharedGroups.filter(function (groupID) {\n          return memberGroups.indexOf(groupID) !== -1;\n        });\n      }\n    }\n    props.groups = props.groups.concat(\n      sharedGroups.filter(function (groupID) {\n        return props.groups.indexOf(groupID) === -1;\n      })\n    );\n    for (let j in sharedGroups) {\n      let groupFeature = featuresByCode[sharedGroups[j]];\n      if (groupFeature.properties.members.indexOf(props.id) === -1) {\n        groupFeature.properties.members.push(props.id);\n      }\n    }\n  }\n\n  function loadRoadSpeedUnit(feature: RegionFeature) {\n    let props = feature.properties;\n    if (feature.geometry) {\n      // only `mph` regions are listed explicitly, else assume `km/h`\n      if (!props.roadSpeedUnit) props.roadSpeedUnit = 'km/h';\n    } else if (props.members) {\n      let vals = Array.from(\n        new Set(\n          props.members\n            .map(function (id) {\n              let member = featuresByCode[id];\n              if (member.geometry) return member.properties.roadSpeedUnit || 'km/h';\n            })\n            .filter(Boolean)\n        )\n      );\n      // if all members have the same value then that's also the value for this feature\n      if (vals.length === 1) props.roadSpeedUnit = vals[0];\n    }\n  }\n\n  function loadRoadHeightUnit(feature: RegionFeature) {\n    let props = feature.properties;\n    if (feature.geometry) {\n      // only `ft` regions are listed explicitly, else assume `m`\n      if (!props.roadHeightUnit) props.roadHeightUnit = 'm';\n    } else if (props.members) {\n      let vals = Array.from(\n        new Set(\n          props.members\n            .map(function (id) {\n              let member = featuresByCode[id];\n              if (member.geometry) return member.properties.roadHeightUnit || 'm';\n            })\n            .filter(Boolean)\n        )\n      );\n      // if all members have the same value then that's also the value for this feature\n      if (vals.length === 1) props.roadHeightUnit = vals[0];\n    }\n  }\n\n  function loadDriveSide(feature: RegionFeature) {\n    let props = feature.properties;\n    if (feature.geometry) {\n      // only `left` regions are listed explicitly, else assume `right`\n      if (!props.driveSide) props.driveSide = 'right';\n    } else if (props.members) {\n      let vals = Array.from(\n        new Set(\n          props.members\n            .map(function (id) {\n              let member = featuresByCode[id];\n              if (member.geometry) return member.properties.driveSide || 'right';\n            })\n            .filter(Boolean)\n        )\n      );\n      // if all members have the same value then that's also the value for this feature\n      if (vals.length === 1) props.driveSide = vals[0];\n    }\n  }\n\n  function loadCallingCodes(feature: RegionFeature) {\n    let props = feature.properties;\n    if (!feature.geometry && props.members) {\n      props.callingCodes = Array.from(\n        new Set(\n          props.members.reduce(function (array, id) {\n            let member = featuresByCode[id];\n            if (member.geometry && member.properties.callingCodes)\n              return array.concat(member.properties.callingCodes);\n            return array;\n          }, [])\n        )\n      );\n    }\n  }\n\n  // Calculates the emoji flag sequence from the alpha-2 code (if any) and caches it\n  function loadFlag(feature: RegionFeature) {\n    if (!feature.properties.iso1A2) return;\n    let flag = feature.properties.iso1A2.replace(/./g, function (char: string) {\n      return String.fromCodePoint(<number>char.charCodeAt(0) + 127397);\n    });\n    feature.properties.emojiFlag = flag;\n  }\n\n  // Populate `members` as the inverse relationship of `groups`\n  function loadMembersForGroupsOf(feature: RegionFeature) {\n    for (let j in feature.properties.groups) {\n      let groupID = feature.properties.groups[j];\n      let groupFeature = featuresByCode[groupID];\n\n      if (!groupFeature.properties.members) groupFeature.properties.members = [];\n      groupFeature.properties.members.push(feature.properties.id);\n    }\n  }\n\n  // Caches features by their identifying strings for rapid lookup\n  function cacheFeatureByIDs(feature: RegionFeature) {\n    let ids: Array<string> = [];\n    for (let k in identifierProps) {\n      let prop = identifierProps[k];\n      let id = feature.properties[prop];\n      if (id) ids.push(id);\n    }\n    if (feature.properties.aliases) {\n      for (let j in feature.properties.aliases) {\n        ids.push(feature.properties.aliases[j]);\n      }\n    }\n    for (let i in ids) {\n      let id = canonicalID(ids[i]);\n      featuresByCode[id] = feature;\n    }\n  }\n}\n\n// Returns the [longitude, latitude] for the location argument\nfunction locArray(loc: Location): Vec2 {\n  if (Array.isArray(loc)) {\n    return <Vec2>loc;\n  } else if ((<PointGeometry>loc).coordinates) {\n    return (<PointGeometry>loc).coordinates;\n  }\n  return (<PointFeature>loc).geometry.coordinates;\n}\n\n// Returns the smallest feature of any kind containing `loc`, if any\nfunction smallestFeature(loc: Location): RegionFeature | null {\n  let query = locArray(loc);\n  let featureProperties: RegionFeatureProperties = whichPolygonGetter(query);\n  if (!featureProperties) return null;\n  return featuresByCode[featureProperties.id];\n}\n\n// Returns the country feature containing `loc`, if any\nfunction countryFeature(loc: Location): RegionFeature | null {\n  let feature = smallestFeature(loc);\n  if (!feature) return null;\n  // a feature without `country` but with geometry is itself a country\n  let countryCode = feature.properties.country || feature.properties.iso1A2;\n  return featuresByCode[<string>countryCode] || null;\n}\n\nlet defaultOpts = {\n  level: undefined,\n  maxLevel: undefined,\n  withProp: undefined\n};\n\n// Returns the feature containing `loc` for the `opts`, if any\nfunction featureForLoc(loc: Location, opts: CodingOptions): RegionFeature | null {\n  let targetLevel = opts.level || 'country';\n  let maxLevel = opts.maxLevel || 'world';\n  let withProp = opts.withProp;\n\n  let targetLevelIndex = levels.indexOf(targetLevel);\n  if (targetLevelIndex === -1) return null;\n\n  let maxLevelIndex = levels.indexOf(maxLevel);\n  if (maxLevelIndex === -1) return null;\n  if (maxLevelIndex < targetLevelIndex) return null;\n\n  if (targetLevel === 'country') {\n    // attempt fast path for country-level coding\n    let fastFeature = countryFeature(loc);\n    if (fastFeature) {\n      if (!withProp || fastFeature.properties[withProp]) {\n        return fastFeature;\n      }\n    }\n  }\n\n  let features = featuresContaining(loc);\n\n  for (let i in features) {\n    let feature = features[i];\n    let levelIndex = levels.indexOf(feature.properties.level);\n    if (\n      feature.properties.level === targetLevel ||\n      // if no feature exists at the target level, return the first feature at the next level up\n      (levelIndex > targetLevelIndex && levelIndex <= maxLevelIndex)\n    ) {\n      if (!withProp || feature.properties[withProp]) {\n        return feature;\n      }\n    }\n  }\n  return null;\n}\n\n// Returns the feature with an identifying property matching `id`, if any\nfunction featureForID(id: string | number): RegionFeature | null {\n  let stringID: string;\n\n  if (typeof id === 'number') {\n    stringID = id.toString();\n    if (stringID.length === 1) {\n      stringID = '00' + stringID;\n    } else if (stringID.length === 2) {\n      stringID = '0' + stringID;\n    }\n  } else {\n    stringID = canonicalID(id);\n  }\n  return featuresByCode[stringID] || null;\n}\n\nfunction smallestFeaturesForBbox(bbox: Bbox): [RegionFeature] {\n  return whichPolygonGetter.bbox(bbox).map(function (props) {\n    return featuresByCode[props.id];\n  });\n}\n\nfunction smallestOrMatchingFeature(query: Location | string | number): RegionFeature | null {\n  if (typeof query === 'object') {\n    return smallestFeature(<Location>query);\n  }\n  return featureForID(query);\n}\n\n// Returns the feature matching the given arguments, if any\nexport function feature(\n  query: Location | string | number,\n  opts: CodingOptions = defaultOpts\n): RegionFeature | null {\n  if (typeof query === 'object') {\n    return featureForLoc(<Location>query, opts);\n  }\n  return featureForID(query);\n}\n\n// Returns the ISO 3166-1 alpha-2 code for the feature matching the arguments, if any\nexport function iso1A2Code(\n  query: Location | string | number,\n  opts: CodingOptions = defaultOpts\n): string | null {\n  opts.withProp = 'iso1A2';\n  let match = feature(query, opts);\n  if (!match) return null;\n  return match.properties.iso1A2 || null;\n}\n\n// Returns the ISO 3166-1 alpha-3 code for the feature matching the arguments, if any\nexport function iso1A3Code(\n  query: Location | string | number,\n  opts: CodingOptions = defaultOpts\n): string | null {\n  opts.withProp = 'iso1A3';\n  let match = feature(query, opts);\n  if (!match) return null;\n  return match.properties.iso1A3 || null;\n}\n\n// Returns the ISO 3166-1 numeric-3 code for the feature matching the arguments, if any\nexport function iso1N3Code(\n  query: Location | string | number,\n  opts: CodingOptions = defaultOpts\n): string | null {\n  opts.withProp = 'iso1N3';\n  let match = feature(query, opts);\n  if (!match) return null;\n  return match.properties.iso1N3 || null;\n}\n\n// Returns the UN M49 code for the feature matching the arguments, if any\nexport function m49Code(\n  query: Location | string | number,\n  opts: CodingOptions = defaultOpts\n): string | null {\n  opts.withProp = 'm49';\n  let match = feature(query, opts);\n  if (!match) return null;\n  return match.properties.m49 || null;\n}\n\n// Returns the Wikidata QID code for the feature matching the arguments, if any\nexport function wikidataQID(\n  query: Location | string | number,\n  opts: CodingOptions = defaultOpts\n): string | null {\n  opts.withProp = 'wikidata';\n  let match = feature(query, opts);\n  if (!match) return null;\n  return match.properties.wikidata;\n}\n\n// Returns the emoji emojiFlag sequence for the feature matching the arguments, if any\nexport function emojiFlag(\n  query: Location | string | number,\n  opts: CodingOptions = defaultOpts\n): string | null {\n  opts.withProp = 'emojiFlag';\n  let match = feature(query, opts);\n  if (!match) return null;\n  return match.properties.emojiFlag || null;\n}\n\n// Returns the ccTLD (country code top-level domain) for the feature matching the arguments, if any\nexport function ccTLD(\n  query: Location | string | number,\n  opts: CodingOptions = defaultOpts\n): string | null {\n  opts.withProp = 'ccTLD';\n  let match = feature(query, opts);\n  if (!match) return null;\n  return match.properties.ccTLD || null;\n}\n\nfunction propertiesForQuery(query: Location | Bbox, property: string): Array<string> {\n  let features = featuresContaining(query, false);\n  return features\n    .map(function (feature) {\n      return feature.properties[property];\n    })\n    .filter(Boolean);\n}\n\n// Returns all the ISO 3166-1 alpha-2 codes of features at the location\nexport function iso1A2Codes(query: Location | Bbox): Array<string> {\n  return propertiesForQuery(query, 'iso1A2');\n}\n\n// Returns all the ISO 3166-1 alpha-3 codes of features at the location\nexport function iso1A3Codes(query: Location | Bbox): Array<string> {\n  return propertiesForQuery(query, 'iso1A3');\n}\n\n// Returns all the ISO 3166-1 numeric-3 codes of features at the location\nexport function iso1N3Codes(query: Location | Bbox): Array<string> {\n  return propertiesForQuery(query, 'iso1N3');\n}\n\n// Returns all the UN M49 codes of features at the location\nexport function m49Codes(query: Location | Bbox): Array<string> {\n  return propertiesForQuery(query, 'm49');\n}\n\n// Returns all the Wikidata QIDs of features at the location\nexport function wikidataQIDs(query: Location | Bbox): Array<string> {\n  return propertiesForQuery(query, 'wikidata');\n}\n\n// Returns all the emoji flag sequences of features at the location\nexport function emojiFlags(query: Location | Bbox): Array<string> {\n  return propertiesForQuery(query, 'emojiFlag');\n}\n\n// Returns all the ccTLD (country code top-level domain) sequences of features at the location\nexport function ccTLDs(query: Location | Bbox): Array<string> {\n  return propertiesForQuery(query, 'ccTLD');\n}\n\n// Returns the feature matching `query` and all features containing it, if any.\n// If passing `true` for `strict`, an exact match will not be included\nexport function featuresContaining(\n  query: Location | Bbox | string | number,\n  strict?: boolean\n): Array<RegionFeature> {\n  let matchingFeatures: Array<RegionFeature>;\n\n  if (Array.isArray(query) && query.length === 4) {\n    // check if bounding box\n    matchingFeatures = smallestFeaturesForBbox(<Bbox>query);\n  } else {\n    let smallestOrMatching = smallestOrMatchingFeature(<Location | string | number>query);\n    matchingFeatures = smallestOrMatching ? [smallestOrMatching] : [];\n  }\n\n  if (!matchingFeatures.length) return [];\n\n  let returnFeatures: Array<RegionFeature>;\n\n  if (!strict || typeof query === 'object') {\n    returnFeatures = matchingFeatures.slice();\n  } else {\n    returnFeatures = [];\n  }\n\n  for (let j in matchingFeatures) {\n    let properties = matchingFeatures[j].properties;\n    for (let i in properties.groups) {\n      let groupID = properties.groups[i];\n      let groupFeature = featuresByCode[groupID];\n      if (returnFeatures.indexOf(groupFeature) === -1) {\n        returnFeatures.push(groupFeature);\n      }\n    }\n  }\n  return returnFeatures;\n}\n\n// Returns the feature matching `id` and all features it contains, if any.\n// If passing `true` for `strict`, an exact match will not be included\nexport function featuresIn(id: string | number, strict?: boolean): Array<RegionFeature> {\n  let feature = featureForID(id);\n  if (!feature) return [];\n\n  let features: Array<RegionFeature> = [];\n\n  if (!strict) {\n    features.push(feature);\n  }\n\n  let properties = feature.properties;\n  if (properties.members) {\n    for (let i in properties.members) {\n      let memberID = properties.members[i];\n      features.push(featuresByCode[memberID]);\n    }\n  }\n  return features;\n}\n\n// Returns a new feature with the properties of the feature matching `id`\n// and the combined geometry of all its component features\nexport function aggregateFeature(id: string | number): RegionFeature | null {\n  let features = featuresIn(id, false);\n  if (features.length === 0) return null;\n\n  let aggregateCoordinates = [];\n  for (let i in features) {\n    let feature = features[i];\n    if (\n      feature.geometry &&\n      feature.geometry.type === 'MultiPolygon' &&\n      feature.geometry.coordinates\n    ) {\n      aggregateCoordinates = aggregateCoordinates.concat(feature.geometry.coordinates);\n    }\n  }\n\n  return {\n    type: 'Feature',\n    properties: features[0].properties,\n    geometry: {\n      type: 'MultiPolygon',\n      coordinates: aggregateCoordinates\n    }\n  };\n}\n\n// Returns true if the feature matching `query` is, or is a part of, the feature matching `bounds`\nexport function isIn(query: Location | string | number, bounds: string | number): boolean | null {\n  let queryFeature = smallestOrMatchingFeature(query);\n  let boundsFeature = featureForID(bounds);\n\n  if (!queryFeature || !boundsFeature) return null;\n\n  if (queryFeature.properties.id === boundsFeature.properties.id) return true;\n  return queryFeature.properties.groups.indexOf(boundsFeature.properties.id) !== -1;\n}\n\n// Returns true if the feature matching `query` is within EU jurisdiction\nexport function isInEuropeanUnion(query: Location | string | number): boolean | null {\n  return isIn(query, 'EU');\n}\n\n// Returns true if the feature matching `query` is, or is within, a United Nations member state\nexport function isInUnitedNations(query: Location | string | number): boolean | null {\n  return isIn(query, 'UN');\n}\n\n// Returns the side traffic drives on in the feature matching `query` as a string (`right` or `left`)\nexport function driveSide(query: Location | string | number): string | null {\n  let feature = smallestOrMatchingFeature(query);\n  return (feature && feature.properties.driveSide) || null;\n}\n\n// Returns the road speed unit for the feature matching `query` as a string (`mph` or `km/h`)\nexport function roadSpeedUnit(query: Location | string | number): string | null {\n  let feature = smallestOrMatchingFeature(query);\n  return (feature && feature.properties.roadSpeedUnit) || null;\n}\n\n// Returns the road vehicle height restriction unit for the feature matching `query` as a string (`ft` or `m`)\nexport function roadHeightUnit(query: Location | string | number): string | null {\n  let feature = smallestOrMatchingFeature(query);\n  return (feature && feature.properties.roadHeightUnit) || null;\n}\n\n// Returns the full international calling codes for phone numbers in the feature matching `query`, if any\nexport function callingCodes(query: Location | string | number): Array<string> {\n  let feature = smallestOrMatchingFeature(query);\n  return (feature && feature.properties.callingCodes) || [];\n}\n", "/**\n * splaytree v3.0.1\n * Fast Splay tree for Node and browser\n *\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n * @preserve\n */\n\nclass Node {\r\n    constructor(key, data) {\r\n        this.next = null;\r\n        this.key = key;\r\n        this.data = data;\r\n        this.left = null;\r\n        this.right = null;\r\n    }\r\n}\n\n/* follows \"An implementation of top-down splaying\"\r\n * by D. Sleator <sleator@cs.cmu.edu> March 1992\r\n */\r\nfunction DEFAULT_COMPARE(a, b) {\r\n    return a > b ? 1 : a < b ? -1 : 0;\r\n}\r\n/**\r\n * Simple top down splay, not requiring i to be in the tree t.\r\n */\r\nfunction splay(i, t, comparator) {\r\n    const N = new Node(null, null);\r\n    let l = N;\r\n    let r = N;\r\n    while (true) {\r\n        const cmp = comparator(i, t.key);\r\n        //if (i < t.key) {\r\n        if (cmp < 0) {\r\n            if (t.left === null)\r\n                break;\r\n            //if (i < t.left.key) {\r\n            if (comparator(i, t.left.key) < 0) {\r\n                const y = t.left; /* rotate right */\r\n                t.left = y.right;\r\n                y.right = t;\r\n                t = y;\r\n                if (t.left === null)\r\n                    break;\r\n            }\r\n            r.left = t; /* link right */\r\n            r = t;\r\n            t = t.left;\r\n            //} else if (i > t.key) {\r\n        }\r\n        else if (cmp > 0) {\r\n            if (t.right === null)\r\n                break;\r\n            //if (i > t.right.key) {\r\n            if (comparator(i, t.right.key) > 0) {\r\n                const y = t.right; /* rotate left */\r\n                t.right = y.left;\r\n                y.left = t;\r\n                t = y;\r\n                if (t.right === null)\r\n                    break;\r\n            }\r\n            l.right = t; /* link left */\r\n            l = t;\r\n            t = t.right;\r\n        }\r\n        else\r\n            break;\r\n    }\r\n    /* assemble */\r\n    l.right = t.left;\r\n    r.left = t.right;\r\n    t.left = N.right;\r\n    t.right = N.left;\r\n    return t;\r\n}\r\nfunction insert(i, data, t, comparator) {\r\n    const node = new Node(i, data);\r\n    if (t === null) {\r\n        node.left = node.right = null;\r\n        return node;\r\n    }\r\n    t = splay(i, t, comparator);\r\n    const cmp = comparator(i, t.key);\r\n    if (cmp < 0) {\r\n        node.left = t.left;\r\n        node.right = t;\r\n        t.left = null;\r\n    }\r\n    else if (cmp >= 0) {\r\n        node.right = t.right;\r\n        node.left = t;\r\n        t.right = null;\r\n    }\r\n    return node;\r\n}\r\nfunction split(key, v, comparator) {\r\n    let left = null;\r\n    let right = null;\r\n    if (v) {\r\n        v = splay(key, v, comparator);\r\n        const cmp = comparator(v.key, key);\r\n        if (cmp === 0) {\r\n            left = v.left;\r\n            right = v.right;\r\n        }\r\n        else if (cmp < 0) {\r\n            right = v.right;\r\n            v.right = null;\r\n            left = v;\r\n        }\r\n        else {\r\n            left = v.left;\r\n            v.left = null;\r\n            right = v;\r\n        }\r\n    }\r\n    return { left, right };\r\n}\r\nfunction merge(left, right, comparator) {\r\n    if (right === null)\r\n        return left;\r\n    if (left === null)\r\n        return right;\r\n    right = splay(left.key, right, comparator);\r\n    right.left = left;\r\n    return right;\r\n}\r\n/**\r\n * Prints level of the tree\r\n */\r\nfunction printRow(root, prefix, isTail, out, printNode) {\r\n    if (root) {\r\n        out(`${prefix}${isTail ? '\u2514\u2500\u2500 ' : '\u251C\u2500\u2500 '}${printNode(root)}\\n`);\r\n        const indent = prefix + (isTail ? '    ' : '\u2502   ');\r\n        if (root.left)\r\n            printRow(root.left, indent, false, out, printNode);\r\n        if (root.right)\r\n            printRow(root.right, indent, true, out, printNode);\r\n    }\r\n}\r\nclass Tree {\r\n    constructor(comparator = DEFAULT_COMPARE) {\r\n        this._root = null;\r\n        this._size = 0;\r\n        this._comparator = comparator;\r\n    }\r\n    /**\r\n     * Inserts a key, allows duplicates\r\n     */\r\n    insert(key, data) {\r\n        this._size++;\r\n        return this._root = insert(key, data, this._root, this._comparator);\r\n    }\r\n    /**\r\n     * Adds a key, if it is not present in the tree\r\n     */\r\n    add(key, data) {\r\n        const node = new Node(key, data);\r\n        if (this._root === null) {\r\n            node.left = node.right = null;\r\n            this._size++;\r\n            this._root = node;\r\n        }\r\n        const comparator = this._comparator;\r\n        const t = splay(key, this._root, comparator);\r\n        const cmp = comparator(key, t.key);\r\n        if (cmp === 0)\r\n            this._root = t;\r\n        else {\r\n            if (cmp < 0) {\r\n                node.left = t.left;\r\n                node.right = t;\r\n                t.left = null;\r\n            }\r\n            else if (cmp > 0) {\r\n                node.right = t.right;\r\n                node.left = t;\r\n                t.right = null;\r\n            }\r\n            this._size++;\r\n            this._root = node;\r\n        }\r\n        return this._root;\r\n    }\r\n    /**\r\n     * @param  {Key} key\r\n     * @return {Node|null}\r\n     */\r\n    remove(key) {\r\n        this._root = this._remove(key, this._root, this._comparator);\r\n    }\r\n    /**\r\n     * Deletes i from the tree if it's there\r\n     */\r\n    _remove(i, t, comparator) {\r\n        let x;\r\n        if (t === null)\r\n            return null;\r\n        t = splay(i, t, comparator);\r\n        const cmp = comparator(i, t.key);\r\n        if (cmp === 0) { /* found it */\r\n            if (t.left === null) {\r\n                x = t.right;\r\n            }\r\n            else {\r\n                x = splay(i, t.left, comparator);\r\n                x.right = t.right;\r\n            }\r\n            this._size--;\r\n            return x;\r\n        }\r\n        return t; /* It wasn't there */\r\n    }\r\n    /**\r\n     * Removes and returns the node with smallest key\r\n     */\r\n    pop() {\r\n        let node = this._root;\r\n        if (node) {\r\n            while (node.left)\r\n                node = node.left;\r\n            this._root = splay(node.key, this._root, this._comparator);\r\n            this._root = this._remove(node.key, this._root, this._comparator);\r\n            return { key: node.key, data: node.data };\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Find without splaying\r\n     */\r\n    findStatic(key) {\r\n        let current = this._root;\r\n        const compare = this._comparator;\r\n        while (current) {\r\n            const cmp = compare(key, current.key);\r\n            if (cmp === 0)\r\n                return current;\r\n            else if (cmp < 0)\r\n                current = current.left;\r\n            else\r\n                current = current.right;\r\n        }\r\n        return null;\r\n    }\r\n    find(key) {\r\n        if (this._root) {\r\n            this._root = splay(key, this._root, this._comparator);\r\n            if (this._comparator(key, this._root.key) !== 0)\r\n                return null;\r\n        }\r\n        return this._root;\r\n    }\r\n    contains(key) {\r\n        let current = this._root;\r\n        const compare = this._comparator;\r\n        while (current) {\r\n            const cmp = compare(key, current.key);\r\n            if (cmp === 0)\r\n                return true;\r\n            else if (cmp < 0)\r\n                current = current.left;\r\n            else\r\n                current = current.right;\r\n        }\r\n        return false;\r\n    }\r\n    forEach(visitor, ctx) {\r\n        let current = this._root;\r\n        const Q = []; /* Initialize stack s */\r\n        let done = false;\r\n        while (!done) {\r\n            if (current !== null) {\r\n                Q.push(current);\r\n                current = current.left;\r\n            }\r\n            else {\r\n                if (Q.length !== 0) {\r\n                    current = Q.pop();\r\n                    visitor.call(ctx, current);\r\n                    current = current.right;\r\n                }\r\n                else\r\n                    done = true;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Walk key range from `low` to `high`. Stops if `fn` returns a value.\r\n     */\r\n    range(low, high, fn, ctx) {\r\n        const Q = [];\r\n        const compare = this._comparator;\r\n        let node = this._root;\r\n        let cmp;\r\n        while (Q.length !== 0 || node) {\r\n            if (node) {\r\n                Q.push(node);\r\n                node = node.left;\r\n            }\r\n            else {\r\n                node = Q.pop();\r\n                cmp = compare(node.key, high);\r\n                if (cmp > 0) {\r\n                    break;\r\n                }\r\n                else if (compare(node.key, low) >= 0) {\r\n                    if (fn.call(ctx, node))\r\n                        return this; // stop if smth is returned\r\n                }\r\n                node = node.right;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns array of keys\r\n     */\r\n    keys() {\r\n        const keys = [];\r\n        this.forEach(({ key }) => keys.push(key));\r\n        return keys;\r\n    }\r\n    /**\r\n     * Returns array of all the data in the nodes\r\n     */\r\n    values() {\r\n        const values = [];\r\n        this.forEach(({ data }) => values.push(data));\r\n        return values;\r\n    }\r\n    min() {\r\n        if (this._root)\r\n            return this.minNode(this._root).key;\r\n        return null;\r\n    }\r\n    max() {\r\n        if (this._root)\r\n            return this.maxNode(this._root).key;\r\n        return null;\r\n    }\r\n    minNode(t = this._root) {\r\n        if (t)\r\n            while (t.left)\r\n                t = t.left;\r\n        return t;\r\n    }\r\n    maxNode(t = this._root) {\r\n        if (t)\r\n            while (t.right)\r\n                t = t.right;\r\n        return t;\r\n    }\r\n    /**\r\n     * Returns node at given index\r\n     */\r\n    at(index) {\r\n        let current = this._root;\r\n        let done = false;\r\n        let i = 0;\r\n        const Q = [];\r\n        while (!done) {\r\n            if (current) {\r\n                Q.push(current);\r\n                current = current.left;\r\n            }\r\n            else {\r\n                if (Q.length > 0) {\r\n                    current = Q.pop();\r\n                    if (i === index)\r\n                        return current;\r\n                    i++;\r\n                    current = current.right;\r\n                }\r\n                else\r\n                    done = true;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    next(d) {\r\n        let root = this._root;\r\n        let successor = null;\r\n        if (d.right) {\r\n            successor = d.right;\r\n            while (successor.left)\r\n                successor = successor.left;\r\n            return successor;\r\n        }\r\n        const comparator = this._comparator;\r\n        while (root) {\r\n            const cmp = comparator(d.key, root.key);\r\n            if (cmp === 0)\r\n                break;\r\n            else if (cmp < 0) {\r\n                successor = root;\r\n                root = root.left;\r\n            }\r\n            else\r\n                root = root.right;\r\n        }\r\n        return successor;\r\n    }\r\n    prev(d) {\r\n        let root = this._root;\r\n        let predecessor = null;\r\n        if (d.left !== null) {\r\n            predecessor = d.left;\r\n            while (predecessor.right)\r\n                predecessor = predecessor.right;\r\n            return predecessor;\r\n        }\r\n        const comparator = this._comparator;\r\n        while (root) {\r\n            const cmp = comparator(d.key, root.key);\r\n            if (cmp === 0)\r\n                break;\r\n            else if (cmp < 0)\r\n                root = root.left;\r\n            else {\r\n                predecessor = root;\r\n                root = root.right;\r\n            }\r\n        }\r\n        return predecessor;\r\n    }\r\n    clear() {\r\n        this._root = null;\r\n        this._size = 0;\r\n        return this;\r\n    }\r\n    toList() {\r\n        return toList(this._root);\r\n    }\r\n    /**\r\n     * Bulk-load items. Both array have to be same size\r\n     */\r\n    load(keys, values = [], presort = false) {\r\n        let size = keys.length;\r\n        const comparator = this._comparator;\r\n        // sort if needed\r\n        if (presort)\r\n            sort(keys, values, 0, size - 1, comparator);\r\n        if (this._root === null) { // empty tree\r\n            this._root = loadRecursive(keys, values, 0, size);\r\n            this._size = size;\r\n        }\r\n        else { // that re-builds the whole tree from two in-order traversals\r\n            const mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\r\n            size = this._size + size;\r\n            this._root = sortedListToBST({ head: mergedList }, 0, size);\r\n        }\r\n        return this;\r\n    }\r\n    isEmpty() { return this._root === null; }\r\n    get size() { return this._size; }\r\n    get root() { return this._root; }\r\n    toString(printNode = (n) => String(n.key)) {\r\n        const out = [];\r\n        printRow(this._root, '', true, (v) => out.push(v), printNode);\r\n        return out.join('');\r\n    }\r\n    update(key, newKey, newData) {\r\n        const comparator = this._comparator;\r\n        let { left, right } = split(key, this._root, comparator);\r\n        if (comparator(key, newKey) < 0) {\r\n            right = insert(newKey, newData, right, comparator);\r\n        }\r\n        else {\r\n            left = insert(newKey, newData, left, comparator);\r\n        }\r\n        this._root = merge(left, right, comparator);\r\n    }\r\n    split(key) {\r\n        return split(key, this._root, this._comparator);\r\n    }\r\n}\r\nfunction loadRecursive(keys, values, start, end) {\r\n    const size = end - start;\r\n    if (size > 0) {\r\n        const middle = start + Math.floor(size / 2);\r\n        const key = keys[middle];\r\n        const data = values[middle];\r\n        const node = new Node(key, data);\r\n        node.left = loadRecursive(keys, values, start, middle);\r\n        node.right = loadRecursive(keys, values, middle + 1, end);\r\n        return node;\r\n    }\r\n    return null;\r\n}\r\nfunction createList(keys, values) {\r\n    const head = new Node(null, null);\r\n    let p = head;\r\n    for (let i = 0; i < keys.length; i++) {\r\n        p = p.next = new Node(keys[i], values[i]);\r\n    }\r\n    p.next = null;\r\n    return head.next;\r\n}\r\nfunction toList(root) {\r\n    let current = root;\r\n    const Q = [];\r\n    let done = false;\r\n    const head = new Node(null, null);\r\n    let p = head;\r\n    while (!done) {\r\n        if (current) {\r\n            Q.push(current);\r\n            current = current.left;\r\n        }\r\n        else {\r\n            if (Q.length > 0) {\r\n                current = p = p.next = Q.pop();\r\n                current = current.right;\r\n            }\r\n            else\r\n                done = true;\r\n        }\r\n    }\r\n    p.next = null; // that'll work even if the tree was empty\r\n    return head.next;\r\n}\r\nfunction sortedListToBST(list, start, end) {\r\n    const size = end - start;\r\n    if (size > 0) {\r\n        const middle = start + Math.floor(size / 2);\r\n        const left = sortedListToBST(list, start, middle);\r\n        const root = list.head;\r\n        root.left = left;\r\n        list.head = list.head.next;\r\n        root.right = sortedListToBST(list, middle + 1, end);\r\n        return root;\r\n    }\r\n    return null;\r\n}\r\nfunction mergeLists(l1, l2, compare) {\r\n    const head = new Node(null, null); // dummy\r\n    let p = head;\r\n    let p1 = l1;\r\n    let p2 = l2;\r\n    while (p1 !== null && p2 !== null) {\r\n        if (compare(p1.key, p2.key) < 0) {\r\n            p.next = p1;\r\n            p1 = p1.next;\r\n        }\r\n        else {\r\n            p.next = p2;\r\n            p2 = p2.next;\r\n        }\r\n        p = p.next;\r\n    }\r\n    if (p1 !== null) {\r\n        p.next = p1;\r\n    }\r\n    else if (p2 !== null) {\r\n        p.next = p2;\r\n    }\r\n    return head.next;\r\n}\r\nfunction sort(keys, values, left, right, compare) {\r\n    if (left >= right)\r\n        return;\r\n    const pivot = keys[(left + right) >> 1];\r\n    let i = left - 1;\r\n    let j = right + 1;\r\n    while (true) {\r\n        do\r\n            i++;\r\n        while (compare(keys[i], pivot) < 0);\r\n        do\r\n            j--;\r\n        while (compare(keys[j], pivot) > 0);\r\n        if (i >= j)\r\n            break;\r\n        let tmp = keys[i];\r\n        keys[i] = keys[j];\r\n        keys[j] = tmp;\r\n        tmp = values[i];\r\n        values[i] = values[j];\r\n        values[j] = tmp;\r\n    }\r\n    sort(keys, values, left, j, compare);\r\n    sort(keys, values, j + 1, right, compare);\r\n}\n\nexport default Tree;\n//# sourceMappingURL=splay.esm.js.map\n", "import SplayTree from 'splaytree';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n/**\n * A bounding box has the format:\n *\n *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n *\n */\nvar isInBbox = function isInBbox(bbox, point) {\n  return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;\n};\n/* Returns either null, or a bbox (aka an ordered pair of points)\n * If there is only one point of overlap, a bbox with identical points\n * will be returned */\n\nvar getBboxOverlap = function getBboxOverlap(b1, b2) {\n  // check if the bboxes overlap at all\n  if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null; // find the middle two X values\n\n  var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;\n  var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x; // find the middle two Y values\n\n  var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;\n  var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y; // put those middle values together to get the overlap\n\n  return {\n    ll: {\n      x: lowerX,\n      y: lowerY\n    },\n    ur: {\n      x: upperX,\n      y: upperY\n    }\n  };\n};\n\n/* Javascript doesn't do integer math. Everything is\n * floating point with percision Number.EPSILON.\n *\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n */\nvar epsilon = Number.EPSILON; // IE Polyfill\n\nif (epsilon === undefined) epsilon = Math.pow(2, -52);\nvar EPSILON_SQ = epsilon * epsilon;\n/* FLP comparator */\n\nvar cmp = function cmp(a, b) {\n  // check if they're both 0\n  if (-epsilon < a && a < epsilon) {\n    if (-epsilon < b && b < epsilon) {\n      return 0;\n    }\n  } // check if they're flp equal\n\n\n  var ab = a - b;\n\n  if (ab * ab < EPSILON_SQ * a * b) {\n    return 0;\n  } // normal comparison\n\n\n  return a < b ? -1 : 1;\n};\n\n/**\n * This class rounds incoming values sufficiently so that\n * floating points problems are, for the most part, avoided.\n *\n * Incoming points are have their x & y values tested against\n * all previously seen x & y values. If either is 'too close'\n * to a previously seen value, it's value is 'snapped' to the\n * previously seen value.\n *\n * All points should be rounded by this class before being\n * stored in any data structures in the rest of this algorithm.\n */\n\nvar PtRounder = /*#__PURE__*/function () {\n  function PtRounder() {\n    _classCallCheck(this, PtRounder);\n\n    this.reset();\n  }\n\n  _createClass(PtRounder, [{\n    key: \"reset\",\n    value: function reset() {\n      this.xRounder = new CoordRounder();\n      this.yRounder = new CoordRounder();\n    }\n  }, {\n    key: \"round\",\n    value: function round(x, y) {\n      return {\n        x: this.xRounder.round(x),\n        y: this.yRounder.round(y)\n      };\n    }\n  }]);\n\n  return PtRounder;\n}();\n\nvar CoordRounder = /*#__PURE__*/function () {\n  function CoordRounder() {\n    _classCallCheck(this, CoordRounder);\n\n    this.tree = new SplayTree(); // preseed with 0 so we don't end up with values < Number.EPSILON\n\n    this.round(0);\n  } // Note: this can rounds input values backwards or forwards.\n  //       You might ask, why not restrict this to just rounding\n  //       forwards? Wouldn't that allow left endpoints to always\n  //       remain left endpoints during splitting (never change to\n  //       right). No - it wouldn't, because we snap intersections\n  //       to endpoints (to establish independence from the segment\n  //       angle for t-intersections).\n\n\n  _createClass(CoordRounder, [{\n    key: \"round\",\n    value: function round(coord) {\n      var node = this.tree.add(coord);\n      var prevNode = this.tree.prev(node);\n\n      if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {\n        this.tree.remove(coord);\n        return prevNode.key;\n      }\n\n      var nextNode = this.tree.next(node);\n\n      if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {\n        this.tree.remove(coord);\n        return nextNode.key;\n      }\n\n      return coord;\n    }\n  }]);\n\n  return CoordRounder;\n}(); // singleton available by import\n\n\nvar rounder = new PtRounder();\n\n/* Cross Product of two vectors with first point at origin */\n\nvar crossProduct = function crossProduct(a, b) {\n  return a.x * b.y - a.y * b.x;\n};\n/* Dot Product of two vectors with first point at origin */\n\nvar dotProduct = function dotProduct(a, b) {\n  return a.x * b.x + a.y * b.y;\n};\n/* Comparator for two vectors with same starting point */\n\nvar compareVectorAngles = function compareVectorAngles(basePt, endPt1, endPt2) {\n  var v1 = {\n    x: endPt1.x - basePt.x,\n    y: endPt1.y - basePt.y\n  };\n  var v2 = {\n    x: endPt2.x - basePt.x,\n    y: endPt2.y - basePt.y\n  };\n  var kross = crossProduct(v1, v2);\n  return cmp(kross, 0);\n};\nvar length = function length(v) {\n  return Math.sqrt(dotProduct(v, v));\n};\n/* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\n\nvar sineOfAngle = function sineOfAngle(pShared, pBase, pAngle) {\n  var vBase = {\n    x: pBase.x - pShared.x,\n    y: pBase.y - pShared.y\n  };\n  var vAngle = {\n    x: pAngle.x - pShared.x,\n    y: pAngle.y - pShared.y\n  };\n  return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n/* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\n\nvar cosineOfAngle = function cosineOfAngle(pShared, pBase, pAngle) {\n  var vBase = {\n    x: pBase.x - pShared.x,\n    y: pBase.y - pShared.y\n  };\n  var vAngle = {\n    x: pAngle.x - pShared.x,\n    y: pAngle.y - pShared.y\n  };\n  return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n/* Get the x coordinate where the given line (defined by a point and vector)\n * crosses the horizontal line with the given y coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\n\nvar horizontalIntersection = function horizontalIntersection(pt, v, y) {\n  if (v.y === 0) return null;\n  return {\n    x: pt.x + v.x / v.y * (y - pt.y),\n    y: y\n  };\n};\n/* Get the y coordinate where the given line (defined by a point and vector)\n * crosses the vertical line with the given x coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\n\nvar verticalIntersection = function verticalIntersection(pt, v, x) {\n  if (v.x === 0) return null;\n  return {\n    x: x,\n    y: pt.y + v.y / v.x * (x - pt.x)\n  };\n};\n/* Get the intersection of two lines, each defined by a base point and a vector.\n * In the case of parrallel lines (including overlapping ones) returns null. */\n\nvar intersection = function intersection(pt1, v1, pt2, v2) {\n  // take some shortcuts for vertical and horizontal lines\n  // this also ensures we don't calculate an intersection and then discover\n  // it's actually outside the bounding box of the line\n  if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);\n  if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);\n  if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);\n  if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y); // General case for non-overlapping segments.\n  // This algorithm is based on Schneider and Eberly.\n  // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n  var kross = crossProduct(v1, v2);\n  if (kross == 0) return null;\n  var ve = {\n    x: pt2.x - pt1.x,\n    y: pt2.y - pt1.y\n  };\n  var d1 = crossProduct(ve, v1) / kross;\n  var d2 = crossProduct(ve, v2) / kross; // take the average of the two calculations to minimize rounding error\n\n  var x1 = pt1.x + d2 * v1.x,\n      x2 = pt2.x + d1 * v2.x;\n  var y1 = pt1.y + d2 * v1.y,\n      y2 = pt2.y + d1 * v2.y;\n  var x = (x1 + x2) / 2;\n  var y = (y1 + y2) / 2;\n  return {\n    x: x,\n    y: y\n  };\n};\n\nvar SweepEvent = /*#__PURE__*/function () {\n  _createClass(SweepEvent, null, [{\n    key: \"compare\",\n    // for ordering sweep events in the sweep event queue\n    value: function compare(a, b) {\n      // favor event with a point that the sweep line hits first\n      var ptCmp = SweepEvent.comparePoints(a.point, b.point);\n      if (ptCmp !== 0) return ptCmp; // the points are the same, so link them if needed\n\n      if (a.point !== b.point) a.link(b); // favor right events over left\n\n      if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1; // we have two matching left or right endpoints\n      // ordering of this case is the same as for their segments\n\n      return Segment.compare(a.segment, b.segment);\n    } // for ordering points in sweep line order\n\n  }, {\n    key: \"comparePoints\",\n    value: function comparePoints(aPt, bPt) {\n      if (aPt.x < bPt.x) return -1;\n      if (aPt.x > bPt.x) return 1;\n      if (aPt.y < bPt.y) return -1;\n      if (aPt.y > bPt.y) return 1;\n      return 0;\n    } // Warning: 'point' input will be modified and re-used (for performance)\n\n  }]);\n\n  function SweepEvent(point, isLeft) {\n    _classCallCheck(this, SweepEvent);\n\n    if (point.events === undefined) point.events = [this];else point.events.push(this);\n    this.point = point;\n    this.isLeft = isLeft; // this.segment, this.otherSE set by factory\n  }\n\n  _createClass(SweepEvent, [{\n    key: \"link\",\n    value: function link(other) {\n      if (other.point === this.point) {\n        throw new Error('Tried to link already linked events');\n      }\n\n      var otherEvents = other.point.events;\n\n      for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {\n        var evt = otherEvents[i];\n        this.point.events.push(evt);\n        evt.point = this.point;\n      }\n\n      this.checkForConsuming();\n    }\n    /* Do a pass over our linked events and check to see if any pair\n     * of segments match, and should be consumed. */\n\n  }, {\n    key: \"checkForConsuming\",\n    value: function checkForConsuming() {\n      // FIXME: The loops in this method run O(n^2) => no good.\n      //        Maintain little ordered sweep event trees?\n      //        Can we maintaining an ordering that avoids the need\n      //        for the re-sorting with getLeftmostComparator in geom-out?\n      // Compare each pair of events to see if other events also match\n      var numEvents = this.point.events.length;\n\n      for (var i = 0; i < numEvents; i++) {\n        var evt1 = this.point.events[i];\n        if (evt1.segment.consumedBy !== undefined) continue;\n\n        for (var j = i + 1; j < numEvents; j++) {\n          var evt2 = this.point.events[j];\n          if (evt2.consumedBy !== undefined) continue;\n          if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;\n          evt1.segment.consume(evt2.segment);\n        }\n      }\n    }\n  }, {\n    key: \"getAvailableLinkedEvents\",\n    value: function getAvailableLinkedEvents() {\n      // point.events is always of length 2 or greater\n      var events = [];\n\n      for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {\n        var evt = this.point.events[i];\n\n        if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n          events.push(evt);\n        }\n      }\n\n      return events;\n    }\n    /**\n     * Returns a comparator function for sorting linked events that will\n     * favor the event that will give us the smallest left-side angle.\n     * All ring construction starts as low as possible heading to the right,\n     * so by always turning left as sharp as possible we'll get polygons\n     * without uncessary loops & holes.\n     *\n     * The comparator function has a compute cache such that it avoids\n     * re-computing already-computed values.\n     */\n\n  }, {\n    key: \"getLeftmostComparator\",\n    value: function getLeftmostComparator(baseEvent) {\n      var _this = this;\n\n      var cache = new Map();\n\n      var fillCache = function fillCache(linkedEvent) {\n        var nextEvent = linkedEvent.otherSE;\n        cache.set(linkedEvent, {\n          sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),\n          cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)\n        });\n      };\n\n      return function (a, b) {\n        if (!cache.has(a)) fillCache(a);\n        if (!cache.has(b)) fillCache(b);\n\n        var _cache$get = cache.get(a),\n            asine = _cache$get.sine,\n            acosine = _cache$get.cosine;\n\n        var _cache$get2 = cache.get(b),\n            bsine = _cache$get2.sine,\n            bcosine = _cache$get2.cosine; // both on or above x-axis\n\n\n        if (asine >= 0 && bsine >= 0) {\n          if (acosine < bcosine) return 1;\n          if (acosine > bcosine) return -1;\n          return 0;\n        } // both below x-axis\n\n\n        if (asine < 0 && bsine < 0) {\n          if (acosine < bcosine) return -1;\n          if (acosine > bcosine) return 1;\n          return 0;\n        } // one above x-axis, one below\n\n\n        if (bsine < asine) return -1;\n        if (bsine > asine) return 1;\n        return 0;\n      };\n    }\n  }]);\n\n  return SweepEvent;\n}();\n\n// segments and sweep events when all else is identical\n\nvar segmentId = 0;\n\nvar Segment = /*#__PURE__*/function () {\n  _createClass(Segment, null, [{\n    key: \"compare\",\n\n    /* This compare() function is for ordering segments in the sweep\n     * line tree, and does so according to the following criteria:\n     *\n     * Consider the vertical line that lies an infinestimal step to the\n     * right of the right-more of the two left endpoints of the input\n     * segments. Imagine slowly moving a point up from negative infinity\n     * in the increasing y direction. Which of the two segments will that\n     * point intersect first? That segment comes 'before' the other one.\n     *\n     * If neither segment would be intersected by such a line, (if one\n     * or more of the segments are vertical) then the line to be considered\n     * is directly on the right-more of the two left inputs.\n     */\n    value: function compare(a, b) {\n      var alx = a.leftSE.point.x;\n      var blx = b.leftSE.point.x;\n      var arx = a.rightSE.point.x;\n      var brx = b.rightSE.point.x; // check if they're even in the same vertical plane\n\n      if (brx < alx) return 1;\n      if (arx < blx) return -1;\n      var aly = a.leftSE.point.y;\n      var bly = b.leftSE.point.y;\n      var ary = a.rightSE.point.y;\n      var bry = b.rightSE.point.y; // is left endpoint of segment B the right-more?\n\n      if (alx < blx) {\n        // are the two segments in the same horizontal plane?\n        if (bly < aly && bly < ary) return 1;\n        if (bly > aly && bly > ary) return -1; // is the B left endpoint colinear to segment A?\n\n        var aCmpBLeft = a.comparePoint(b.leftSE.point);\n        if (aCmpBLeft < 0) return 1;\n        if (aCmpBLeft > 0) return -1; // is the A right endpoint colinear to segment B ?\n\n        var bCmpARight = b.comparePoint(a.rightSE.point);\n        if (bCmpARight !== 0) return bCmpARight; // colinear segments, consider the one with left-more\n        // left endpoint to be first (arbitrary?)\n\n        return -1;\n      } // is left endpoint of segment A the right-more?\n\n\n      if (alx > blx) {\n        if (aly < bly && aly < bry) return -1;\n        if (aly > bly && aly > bry) return 1; // is the A left endpoint colinear to segment B?\n\n        var bCmpALeft = b.comparePoint(a.leftSE.point);\n        if (bCmpALeft !== 0) return bCmpALeft; // is the B right endpoint colinear to segment A?\n\n        var aCmpBRight = a.comparePoint(b.rightSE.point);\n        if (aCmpBRight < 0) return 1;\n        if (aCmpBRight > 0) return -1; // colinear segments, consider the one with left-more\n        // left endpoint to be first (arbitrary?)\n\n        return 1;\n      } // if we get here, the two left endpoints are in the same\n      // vertical plane, ie alx === blx\n      // consider the lower left-endpoint to come first\n\n\n      if (aly < bly) return -1;\n      if (aly > bly) return 1; // left endpoints are identical\n      // check for colinearity by using the left-more right endpoint\n      // is the A right endpoint more left-more?\n\n      if (arx < brx) {\n        var _bCmpARight = b.comparePoint(a.rightSE.point);\n\n        if (_bCmpARight !== 0) return _bCmpARight;\n      } // is the B right endpoint more left-more?\n\n\n      if (arx > brx) {\n        var _aCmpBRight = a.comparePoint(b.rightSE.point);\n\n        if (_aCmpBRight < 0) return 1;\n        if (_aCmpBRight > 0) return -1;\n      }\n\n      if (arx !== brx) {\n        // are these two [almost] vertical segments with opposite orientation?\n        // if so, the one with the lower right endpoint comes first\n        var ay = ary - aly;\n        var ax = arx - alx;\n        var by = bry - bly;\n        var bx = brx - blx;\n        if (ay > ax && by < bx) return 1;\n        if (ay < ax && by > bx) return -1;\n      } // we have colinear segments with matching orientation\n      // consider the one with more left-more right endpoint to be first\n\n\n      if (arx > brx) return 1;\n      if (arx < brx) return -1; // if we get here, two two right endpoints are in the same\n      // vertical plane, ie arx === brx\n      // consider the lower right-endpoint to come first\n\n      if (ary < bry) return -1;\n      if (ary > bry) return 1; // right endpoints identical as well, so the segments are idential\n      // fall back on creation order as consistent tie-breaker\n\n      if (a.id < b.id) return -1;\n      if (a.id > b.id) return 1; // identical segment, ie a === b\n\n      return 0;\n    }\n    /* Warning: a reference to ringWindings input will be stored,\n     *  and possibly will be later modified */\n\n  }]);\n\n  function Segment(leftSE, rightSE, rings, windings) {\n    _classCallCheck(this, Segment);\n\n    this.id = ++segmentId;\n    this.leftSE = leftSE;\n    leftSE.segment = this;\n    leftSE.otherSE = rightSE;\n    this.rightSE = rightSE;\n    rightSE.segment = this;\n    rightSE.otherSE = leftSE;\n    this.rings = rings;\n    this.windings = windings; // left unset for performance, set later in algorithm\n    // this.ringOut, this.consumedBy, this.prev\n  }\n\n  _createClass(Segment, [{\n    key: \"replaceRightSE\",\n\n    /* When a segment is split, the rightSE is replaced with a new sweep event */\n    value: function replaceRightSE(newRightSE) {\n      this.rightSE = newRightSE;\n      this.rightSE.segment = this;\n      this.rightSE.otherSE = this.leftSE;\n      this.leftSE.otherSE = this.rightSE;\n    }\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      var y1 = this.leftSE.point.y;\n      var y2 = this.rightSE.point.y;\n      return {\n        ll: {\n          x: this.leftSE.point.x,\n          y: y1 < y2 ? y1 : y2\n        },\n        ur: {\n          x: this.rightSE.point.x,\n          y: y1 > y2 ? y1 : y2\n        }\n      };\n    }\n    /* A vector from the left point to the right */\n\n  }, {\n    key: \"vector\",\n    value: function vector() {\n      return {\n        x: this.rightSE.point.x - this.leftSE.point.x,\n        y: this.rightSE.point.y - this.leftSE.point.y\n      };\n    }\n  }, {\n    key: \"isAnEndpoint\",\n    value: function isAnEndpoint(pt) {\n      return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;\n    }\n    /* Compare this segment with a point.\n     *\n     * A point P is considered to be colinear to a segment if there\n     * exists a distance D such that if we travel along the segment\n     * from one * endpoint towards the other a distance D, we find\n     * ourselves at point P.\n     *\n     * Return value indicates:\n     *\n     *   1: point lies above the segment (to the left of vertical)\n     *   0: point is colinear to segment\n     *  -1: point lies below the segment (to the right of vertical)\n     */\n\n  }, {\n    key: \"comparePoint\",\n    value: function comparePoint(point) {\n      if (this.isAnEndpoint(point)) return 0;\n      var lPt = this.leftSE.point;\n      var rPt = this.rightSE.point;\n      var v = this.vector(); // Exactly vertical segments.\n\n      if (lPt.x === rPt.x) {\n        if (point.x === lPt.x) return 0;\n        return point.x < lPt.x ? 1 : -1;\n      } // Nearly vertical segments with an intersection.\n      // Check to see where a point on the line with matching Y coordinate is.\n\n\n      var yDist = (point.y - lPt.y) / v.y;\n      var xFromYDist = lPt.x + yDist * v.x;\n      if (point.x === xFromYDist) return 0; // General case.\n      // Check to see where a point on the line with matching X coordinate is.\n\n      var xDist = (point.x - lPt.x) / v.x;\n      var yFromXDist = lPt.y + xDist * v.y;\n      if (point.y === yFromXDist) return 0;\n      return point.y < yFromXDist ? -1 : 1;\n    }\n    /**\n     * Given another segment, returns the first non-trivial intersection\n     * between the two segments (in terms of sweep line ordering), if it exists.\n     *\n     * A 'non-trivial' intersection is one that will cause one or both of the\n     * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n     *\n     *   * endpoint of segA with endpoint of segB --> trivial\n     *   * endpoint of segA with point along segB --> non-trivial\n     *   * endpoint of segB with point along segA --> non-trivial\n     *   * point along segA with point along segB --> non-trivial\n     *\n     * If no non-trivial intersection exists, return null\n     * Else, return null.\n     */\n\n  }, {\n    key: \"getIntersection\",\n    value: function getIntersection(other) {\n      // If bboxes don't overlap, there can't be any intersections\n      var tBbox = this.bbox();\n      var oBbox = other.bbox();\n      var bboxOverlap = getBboxOverlap(tBbox, oBbox);\n      if (bboxOverlap === null) return null; // We first check to see if the endpoints can be considered intersections.\n      // This will 'snap' intersections to endpoints if possible, and will\n      // handle cases of colinearity.\n\n      var tlp = this.leftSE.point;\n      var trp = this.rightSE.point;\n      var olp = other.leftSE.point;\n      var orp = other.rightSE.point; // does each endpoint touch the other segment?\n      // note that we restrict the 'touching' definition to only allow segments\n      // to touch endpoints that lie forward from where we are in the sweep line pass\n\n      var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;\n      var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;\n      var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;\n      var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0; // do left endpoints match?\n\n      if (touchesThisLSE && touchesOtherLSE) {\n        // these two cases are for colinear segments with matching left\n        // endpoints, and one segment being longer than the other\n        if (touchesThisRSE && !touchesOtherRSE) return trp;\n        if (!touchesThisRSE && touchesOtherRSE) return orp; // either the two segments match exactly (two trival intersections)\n        // or just on their left endpoint (one trivial intersection\n\n        return null;\n      } // does this left endpoint matches (other doesn't)\n\n\n      if (touchesThisLSE) {\n        // check for segments that just intersect on opposing endpoints\n        if (touchesOtherRSE) {\n          if (tlp.x === orp.x && tlp.y === orp.y) return null;\n        } // t-intersection on left endpoint\n\n\n        return tlp;\n      } // does other left endpoint matches (this doesn't)\n\n\n      if (touchesOtherLSE) {\n        // check for segments that just intersect on opposing endpoints\n        if (touchesThisRSE) {\n          if (trp.x === olp.x && trp.y === olp.y) return null;\n        } // t-intersection on left endpoint\n\n\n        return olp;\n      } // trivial intersection on right endpoints\n\n\n      if (touchesThisRSE && touchesOtherRSE) return null; // t-intersections on just one right endpoint\n\n      if (touchesThisRSE) return trp;\n      if (touchesOtherRSE) return orp; // None of our endpoints intersect. Look for a general intersection between\n      // infinite lines laid over the segments\n\n      var pt = intersection(tlp, this.vector(), olp, other.vector()); // are the segments parrallel? Note that if they were colinear with overlap,\n      // they would have an endpoint intersection and that case was already handled above\n\n      if (pt === null) return null; // is the intersection found between the lines not on the segments?\n\n      if (!isInBbox(bboxOverlap, pt)) return null; // round the the computed point if needed\n\n      return rounder.round(pt.x, pt.y);\n    }\n    /**\n     * Split the given segment into multiple segments on the given points.\n     *  * Each existing segment will retain its leftSE and a new rightSE will be\n     *    generated for it.\n     *  * A new segment will be generated which will adopt the original segment's\n     *    rightSE, and a new leftSE will be generated for it.\n     *  * If there are more than two points given to split on, new segments\n     *    in the middle will be generated with new leftSE and rightSE's.\n     *  * An array of the newly generated SweepEvents will be returned.\n     *\n     * Warning: input array of points is modified\n     */\n\n  }, {\n    key: \"split\",\n    value: function split(point) {\n      var newEvents = [];\n      var alreadyLinked = point.events !== undefined;\n      var newLeftSE = new SweepEvent(point, true);\n      var newRightSE = new SweepEvent(point, false);\n      var oldRightSE = this.rightSE;\n      this.replaceRightSE(newRightSE);\n      newEvents.push(newRightSE);\n      newEvents.push(newLeftSE);\n      var newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice()); // when splitting a nearly vertical downward-facing segment,\n      // sometimes one of the resulting new segments is vertical, in which\n      // case its left and right events may need to be swapped\n\n      if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n        newSeg.swapEvents();\n      }\n\n      if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n        this.swapEvents();\n      } // in the point we just used to create new sweep events with was already\n      // linked to other events, we need to check if either of the affected\n      // segments should be consumed\n\n\n      if (alreadyLinked) {\n        newLeftSE.checkForConsuming();\n        newRightSE.checkForConsuming();\n      }\n\n      return newEvents;\n    }\n    /* Swap which event is left and right */\n\n  }, {\n    key: \"swapEvents\",\n    value: function swapEvents() {\n      var tmpEvt = this.rightSE;\n      this.rightSE = this.leftSE;\n      this.leftSE = tmpEvt;\n      this.leftSE.isLeft = true;\n      this.rightSE.isLeft = false;\n\n      for (var i = 0, iMax = this.windings.length; i < iMax; i++) {\n        this.windings[i] *= -1;\n      }\n    }\n    /* Consume another segment. We take their rings under our wing\n     * and mark them as consumed. Use for perfectly overlapping segments */\n\n  }, {\n    key: \"consume\",\n    value: function consume(other) {\n      var consumer = this;\n      var consumee = other;\n\n      while (consumer.consumedBy) {\n        consumer = consumer.consumedBy;\n      }\n\n      while (consumee.consumedBy) {\n        consumee = consumee.consumedBy;\n      }\n\n      var cmp = Segment.compare(consumer, consumee);\n      if (cmp === 0) return; // already consumed\n      // the winner of the consumption is the earlier segment\n      // according to sweep line ordering\n\n      if (cmp > 0) {\n        var tmp = consumer;\n        consumer = consumee;\n        consumee = tmp;\n      } // make sure a segment doesn't consume it's prev\n\n\n      if (consumer.prev === consumee) {\n        var _tmp = consumer;\n        consumer = consumee;\n        consumee = _tmp;\n      }\n\n      for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n        var ring = consumee.rings[i];\n        var winding = consumee.windings[i];\n        var index = consumer.rings.indexOf(ring);\n\n        if (index === -1) {\n          consumer.rings.push(ring);\n          consumer.windings.push(winding);\n        } else consumer.windings[index] += winding;\n      }\n\n      consumee.rings = null;\n      consumee.windings = null;\n      consumee.consumedBy = consumer; // mark sweep events consumed as to maintain ordering in sweep event queue\n\n      consumee.leftSE.consumedBy = consumer.leftSE;\n      consumee.rightSE.consumedBy = consumer.rightSE;\n    }\n    /* The first segment previous segment chain that is in the result */\n\n  }, {\n    key: \"prevInResult\",\n    value: function prevInResult() {\n      if (this._prevInResult !== undefined) return this._prevInResult;\n      if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();\n      return this._prevInResult;\n    }\n  }, {\n    key: \"beforeState\",\n    value: function beforeState() {\n      if (this._beforeState !== undefined) return this._beforeState;\n      if (!this.prev) this._beforeState = {\n        rings: [],\n        windings: [],\n        multiPolys: []\n      };else {\n        var seg = this.prev.consumedBy || this.prev;\n        this._beforeState = seg.afterState();\n      }\n      return this._beforeState;\n    }\n  }, {\n    key: \"afterState\",\n    value: function afterState() {\n      if (this._afterState !== undefined) return this._afterState;\n      var beforeState = this.beforeState();\n      this._afterState = {\n        rings: beforeState.rings.slice(0),\n        windings: beforeState.windings.slice(0),\n        multiPolys: []\n      };\n      var ringsAfter = this._afterState.rings;\n      var windingsAfter = this._afterState.windings;\n      var mpsAfter = this._afterState.multiPolys; // calculate ringsAfter, windingsAfter\n\n      for (var i = 0, iMax = this.rings.length; i < iMax; i++) {\n        var ring = this.rings[i];\n        var winding = this.windings[i];\n        var index = ringsAfter.indexOf(ring);\n\n        if (index === -1) {\n          ringsAfter.push(ring);\n          windingsAfter.push(winding);\n        } else windingsAfter[index] += winding;\n      } // calcualte polysAfter\n\n\n      var polysAfter = [];\n      var polysExclude = [];\n\n      for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {\n        if (windingsAfter[_i] === 0) continue; // non-zero rule\n\n        var _ring = ringsAfter[_i];\n        var poly = _ring.poly;\n        if (polysExclude.indexOf(poly) !== -1) continue;\n        if (_ring.isExterior) polysAfter.push(poly);else {\n          if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);\n\n          var _index = polysAfter.indexOf(_ring.poly);\n\n          if (_index !== -1) polysAfter.splice(_index, 1);\n        }\n      } // calculate multiPolysAfter\n\n\n      for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {\n        var mp = polysAfter[_i2].multiPoly;\n        if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);\n      }\n\n      return this._afterState;\n    }\n    /* Is this segment part of the final result? */\n\n  }, {\n    key: \"isInResult\",\n    value: function isInResult() {\n      // if we've been consumed, we're not in the result\n      if (this.consumedBy) return false;\n      if (this._isInResult !== undefined) return this._isInResult;\n      var mpsBefore = this.beforeState().multiPolys;\n      var mpsAfter = this.afterState().multiPolys;\n\n      switch (operation.type) {\n        case 'union':\n          {\n            // UNION - included iff:\n            //  * On one side of us there is 0 poly interiors AND\n            //  * On the other side there is 1 or more.\n            var noBefores = mpsBefore.length === 0;\n            var noAfters = mpsAfter.length === 0;\n            this._isInResult = noBefores !== noAfters;\n            break;\n          }\n\n        case 'intersection':\n          {\n            // INTERSECTION - included iff:\n            //  * on one side of us all multipolys are rep. with poly interiors AND\n            //  * on the other side of us, not all multipolys are repsented\n            //    with poly interiors\n            var least;\n            var most;\n\n            if (mpsBefore.length < mpsAfter.length) {\n              least = mpsBefore.length;\n              most = mpsAfter.length;\n            } else {\n              least = mpsAfter.length;\n              most = mpsBefore.length;\n            }\n\n            this._isInResult = most === operation.numMultiPolys && least < most;\n            break;\n          }\n\n        case 'xor':\n          {\n            // XOR - included iff:\n            //  * the difference between the number of multipolys represented\n            //    with poly interiors on our two sides is an odd number\n            var diff = Math.abs(mpsBefore.length - mpsAfter.length);\n            this._isInResult = diff % 2 === 1;\n            break;\n          }\n\n        case 'difference':\n          {\n            // DIFFERENCE included iff:\n            //  * on exactly one side, we have just the subject\n            var isJustSubject = function isJustSubject(mps) {\n              return mps.length === 1 && mps[0].isSubject;\n            };\n\n            this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n            break;\n          }\n\n        default:\n          throw new Error(\"Unrecognized operation type found \".concat(operation.type));\n      }\n\n      return this._isInResult;\n    }\n  }], [{\n    key: \"fromRing\",\n    value: function fromRing(pt1, pt2, ring) {\n      var leftPt, rightPt, winding; // ordering the two points according to sweep line ordering\n\n      var cmpPts = SweepEvent.comparePoints(pt1, pt2);\n\n      if (cmpPts < 0) {\n        leftPt = pt1;\n        rightPt = pt2;\n        winding = 1;\n      } else if (cmpPts > 0) {\n        leftPt = pt2;\n        rightPt = pt1;\n        winding = -1;\n      } else throw new Error(\"Tried to create degenerate segment at [\".concat(pt1.x, \", \").concat(pt1.y, \"]\"));\n\n      var leftSE = new SweepEvent(leftPt, true);\n      var rightSE = new SweepEvent(rightPt, false);\n      return new Segment(leftSE, rightSE, [ring], [winding]);\n    }\n  }]);\n\n  return Segment;\n}();\n\nvar RingIn = /*#__PURE__*/function () {\n  function RingIn(geomRing, poly, isExterior) {\n    _classCallCheck(this, RingIn);\n\n    if (!Array.isArray(geomRing) || geomRing.length === 0) {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n    }\n\n    this.poly = poly;\n    this.isExterior = isExterior;\n    this.segments = [];\n\n    if (typeof geomRing[0][0] !== 'number' || typeof geomRing[0][1] !== 'number') {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n    }\n\n    var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);\n    this.bbox = {\n      ll: {\n        x: firstPoint.x,\n        y: firstPoint.y\n      },\n      ur: {\n        x: firstPoint.x,\n        y: firstPoint.y\n      }\n    };\n    var prevPoint = firstPoint;\n\n    for (var i = 1, iMax = geomRing.length; i < iMax; i++) {\n      if (typeof geomRing[i][0] !== 'number' || typeof geomRing[i][1] !== 'number') {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      var point = rounder.round(geomRing[i][0], geomRing[i][1]); // skip repeated points\n\n      if (point.x === prevPoint.x && point.y === prevPoint.y) continue;\n      this.segments.push(Segment.fromRing(prevPoint, point, this));\n      if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;\n      if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;\n      if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;\n      if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;\n      prevPoint = point;\n    } // add segment from last to first if last is not the same as first\n\n\n    if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {\n      this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));\n    }\n  }\n\n  _createClass(RingIn, [{\n    key: \"getSweepEvents\",\n    value: function getSweepEvents() {\n      var sweepEvents = [];\n\n      for (var i = 0, iMax = this.segments.length; i < iMax; i++) {\n        var segment = this.segments[i];\n        sweepEvents.push(segment.leftSE);\n        sweepEvents.push(segment.rightSE);\n      }\n\n      return sweepEvents;\n    }\n  }]);\n\n  return RingIn;\n}();\nvar PolyIn = /*#__PURE__*/function () {\n  function PolyIn(geomPoly, multiPoly) {\n    _classCallCheck(this, PolyIn);\n\n    if (!Array.isArray(geomPoly)) {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n    }\n\n    this.exteriorRing = new RingIn(geomPoly[0], this, true); // copy by value\n\n    this.bbox = {\n      ll: {\n        x: this.exteriorRing.bbox.ll.x,\n        y: this.exteriorRing.bbox.ll.y\n      },\n      ur: {\n        x: this.exteriorRing.bbox.ur.x,\n        y: this.exteriorRing.bbox.ur.y\n      }\n    };\n    this.interiorRings = [];\n\n    for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {\n      var ring = new RingIn(geomPoly[i], this, false);\n      if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;\n      if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;\n      if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;\n      if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;\n      this.interiorRings.push(ring);\n    }\n\n    this.multiPoly = multiPoly;\n  }\n\n  _createClass(PolyIn, [{\n    key: \"getSweepEvents\",\n    value: function getSweepEvents() {\n      var sweepEvents = this.exteriorRing.getSweepEvents();\n\n      for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n        var ringSweepEvents = this.interiorRings[i].getSweepEvents();\n\n        for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n          sweepEvents.push(ringSweepEvents[j]);\n        }\n      }\n\n      return sweepEvents;\n    }\n  }]);\n\n  return PolyIn;\n}();\nvar MultiPolyIn = /*#__PURE__*/function () {\n  function MultiPolyIn(geom, isSubject) {\n    _classCallCheck(this, MultiPolyIn);\n\n    if (!Array.isArray(geom)) {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n    }\n\n    try {\n      // if the input looks like a polygon, convert it to a multipolygon\n      if (typeof geom[0][0][0] === 'number') geom = [geom];\n    } catch (ex) {// The input is either malformed or has empty arrays.\n      // In either case, it will be handled later on.\n    }\n\n    this.polys = [];\n    this.bbox = {\n      ll: {\n        x: Number.POSITIVE_INFINITY,\n        y: Number.POSITIVE_INFINITY\n      },\n      ur: {\n        x: Number.NEGATIVE_INFINITY,\n        y: Number.NEGATIVE_INFINITY\n      }\n    };\n\n    for (var i = 0, iMax = geom.length; i < iMax; i++) {\n      var poly = new PolyIn(geom[i], this);\n      if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;\n      if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;\n      if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;\n      if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;\n      this.polys.push(poly);\n    }\n\n    this.isSubject = isSubject;\n  }\n\n  _createClass(MultiPolyIn, [{\n    key: \"getSweepEvents\",\n    value: function getSweepEvents() {\n      var sweepEvents = [];\n\n      for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n        var polySweepEvents = this.polys[i].getSweepEvents();\n\n        for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n          sweepEvents.push(polySweepEvents[j]);\n        }\n      }\n\n      return sweepEvents;\n    }\n  }]);\n\n  return MultiPolyIn;\n}();\n\nvar RingOut = /*#__PURE__*/function () {\n  _createClass(RingOut, null, [{\n    key: \"factory\",\n\n    /* Given the segments from the sweep line pass, compute & return a series\n     * of closed rings from all the segments marked to be part of the result */\n    value: function factory(allSegments) {\n      var ringsOut = [];\n\n      for (var i = 0, iMax = allSegments.length; i < iMax; i++) {\n        var segment = allSegments[i];\n        if (!segment.isInResult() || segment.ringOut) continue;\n        var prevEvent = null;\n        var event = segment.leftSE;\n        var nextEvent = segment.rightSE;\n        var events = [event];\n        var startingPoint = event.point;\n        var intersectionLEs = [];\n        /* Walk the chain of linked events to form a closed ring */\n\n        while (true) {\n          prevEvent = event;\n          event = nextEvent;\n          events.push(event);\n          /* Is the ring complete? */\n\n          if (event.point === startingPoint) break;\n\n          while (true) {\n            var availableLEs = event.getAvailableLinkedEvents();\n            /* Did we hit a dead end? This shouldn't happen. Indicates some earlier\n             * part of the algorithm malfunctioned... please file a bug report. */\n\n            if (availableLEs.length === 0) {\n              var firstPt = events[0].point;\n              var lastPt = events[events.length - 1].point;\n              throw new Error(\"Unable to complete output ring starting at [\".concat(firstPt.x, \",\") + \" \".concat(firstPt.y, \"]. Last matching segment found ends at\") + \" [\".concat(lastPt.x, \", \").concat(lastPt.y, \"].\"));\n            }\n            /* Only one way to go, so cotinue on the path */\n\n\n            if (availableLEs.length === 1) {\n              nextEvent = availableLEs[0].otherSE;\n              break;\n            }\n            /* We must have an intersection. Check for a completed loop */\n\n\n            var indexLE = null;\n\n            for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n              if (intersectionLEs[j].point === event.point) {\n                indexLE = j;\n                break;\n              }\n            }\n            /* Found a completed loop. Cut that off and make a ring */\n\n\n            if (indexLE !== null) {\n              var intersectionLE = intersectionLEs.splice(indexLE)[0];\n              var ringEvents = events.splice(intersectionLE.index);\n              ringEvents.unshift(ringEvents[0].otherSE);\n              ringsOut.push(new RingOut(ringEvents.reverse()));\n              continue;\n            }\n            /* register the intersection */\n\n\n            intersectionLEs.push({\n              index: events.length,\n              point: event.point\n            });\n            /* Choose the left-most option to continue the walk */\n\n            var comparator = event.getLeftmostComparator(prevEvent);\n            nextEvent = availableLEs.sort(comparator)[0].otherSE;\n            break;\n          }\n        }\n\n        ringsOut.push(new RingOut(events));\n      }\n\n      return ringsOut;\n    }\n  }]);\n\n  function RingOut(events) {\n    _classCallCheck(this, RingOut);\n\n    this.events = events;\n\n    for (var i = 0, iMax = events.length; i < iMax; i++) {\n      events[i].segment.ringOut = this;\n    }\n\n    this.poly = null;\n  }\n\n  _createClass(RingOut, [{\n    key: \"getGeom\",\n    value: function getGeom() {\n      // Remove superfluous points (ie extra points along a straight line),\n      var prevPt = this.events[0].point;\n      var points = [prevPt];\n\n      for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n        var _pt = this.events[i].point;\n        var _nextPt = this.events[i + 1].point;\n        if (compareVectorAngles(_pt, prevPt, _nextPt) === 0) continue;\n        points.push(_pt);\n        prevPt = _pt;\n      } // ring was all (within rounding error of angle calc) colinear points\n\n\n      if (points.length === 1) return null; // check if the starting point is necessary\n\n      var pt = points[0];\n      var nextPt = points[1];\n      if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();\n      points.push(points[0]);\n      var step = this.isExteriorRing() ? 1 : -1;\n      var iStart = this.isExteriorRing() ? 0 : points.length - 1;\n      var iEnd = this.isExteriorRing() ? points.length : -1;\n      var orderedPoints = [];\n\n      for (var _i = iStart; _i != iEnd; _i += step) {\n        orderedPoints.push([points[_i].x, points[_i].y]);\n      }\n\n      return orderedPoints;\n    }\n  }, {\n    key: \"isExteriorRing\",\n    value: function isExteriorRing() {\n      if (this._isExteriorRing === undefined) {\n        var enclosing = this.enclosingRing();\n        this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n      }\n\n      return this._isExteriorRing;\n    }\n  }, {\n    key: \"enclosingRing\",\n    value: function enclosingRing() {\n      if (this._enclosingRing === undefined) {\n        this._enclosingRing = this._calcEnclosingRing();\n      }\n\n      return this._enclosingRing;\n    }\n    /* Returns the ring that encloses this one, if any */\n\n  }, {\n    key: \"_calcEnclosingRing\",\n    value: function _calcEnclosingRing() {\n      // start with the ealier sweep line event so that the prevSeg\n      // chain doesn't lead us inside of a loop of ours\n      var leftMostEvt = this.events[0];\n\n      for (var i = 1, iMax = this.events.length; i < iMax; i++) {\n        var evt = this.events[i];\n        if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n      }\n\n      var prevSeg = leftMostEvt.segment.prevInResult();\n      var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n\n      while (true) {\n        // no segment found, thus no ring can enclose us\n        if (!prevSeg) return null; // no segments below prev segment found, thus the ring of the prev\n        // segment must loop back around and enclose us\n\n        if (!prevPrevSeg) return prevSeg.ringOut; // if the two segments are of different rings, the ring of the prev\n        // segment must either loop around us or the ring of the prev prev\n        // seg, which would make us and the ring of the prev peers\n\n        if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n          if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n            return prevSeg.ringOut;\n          } else return prevSeg.ringOut.enclosingRing();\n        } // two segments are from the same ring, so this was a penisula\n        // of that ring. iterate downward, keep searching\n\n\n        prevSeg = prevPrevSeg.prevInResult();\n        prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n      }\n    }\n  }]);\n\n  return RingOut;\n}();\nvar PolyOut = /*#__PURE__*/function () {\n  function PolyOut(exteriorRing) {\n    _classCallCheck(this, PolyOut);\n\n    this.exteriorRing = exteriorRing;\n    exteriorRing.poly = this;\n    this.interiorRings = [];\n  }\n\n  _createClass(PolyOut, [{\n    key: \"addInterior\",\n    value: function addInterior(ring) {\n      this.interiorRings.push(ring);\n      ring.poly = this;\n    }\n  }, {\n    key: \"getGeom\",\n    value: function getGeom() {\n      var geom = [this.exteriorRing.getGeom()]; // exterior ring was all (within rounding error of angle calc) colinear points\n\n      if (geom[0] === null) return null;\n\n      for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n        var ringGeom = this.interiorRings[i].getGeom(); // interior ring was all (within rounding error of angle calc) colinear points\n\n        if (ringGeom === null) continue;\n        geom.push(ringGeom);\n      }\n\n      return geom;\n    }\n  }]);\n\n  return PolyOut;\n}();\nvar MultiPolyOut = /*#__PURE__*/function () {\n  function MultiPolyOut(rings) {\n    _classCallCheck(this, MultiPolyOut);\n\n    this.rings = rings;\n    this.polys = this._composePolys(rings);\n  }\n\n  _createClass(MultiPolyOut, [{\n    key: \"getGeom\",\n    value: function getGeom() {\n      var geom = [];\n\n      for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n        var polyGeom = this.polys[i].getGeom(); // exterior ring was all (within rounding error of angle calc) colinear points\n\n        if (polyGeom === null) continue;\n        geom.push(polyGeom);\n      }\n\n      return geom;\n    }\n  }, {\n    key: \"_composePolys\",\n    value: function _composePolys(rings) {\n      var polys = [];\n\n      for (var i = 0, iMax = rings.length; i < iMax; i++) {\n        var ring = rings[i];\n        if (ring.poly) continue;\n        if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {\n          var enclosingRing = ring.enclosingRing();\n          if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));\n          enclosingRing.poly.addInterior(ring);\n        }\n      }\n\n      return polys;\n    }\n  }]);\n\n  return MultiPolyOut;\n}();\n\n/**\n * NOTE:  We must be careful not to change any segments while\n *        they are in the SplayTree. AFAIK, there's no way to tell\n *        the tree to rebalance itself - thus before splitting\n *        a segment that's in the tree, we remove it from the tree,\n *        do the split, then re-insert it. (Even though splitting a\n *        segment *shouldn't* change its correct position in the\n *        sweep line tree, the reality is because of rounding errors,\n *        it sometimes does.)\n */\n\nvar SweepLine = /*#__PURE__*/function () {\n  function SweepLine(queue) {\n    var comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;\n\n    _classCallCheck(this, SweepLine);\n\n    this.queue = queue;\n    this.tree = new SplayTree(comparator);\n    this.segments = [];\n  }\n\n  _createClass(SweepLine, [{\n    key: \"process\",\n    value: function process(event) {\n      var segment = event.segment;\n      var newEvents = []; // if we've already been consumed by another segment,\n      // clean up our body parts and get out\n\n      if (event.consumedBy) {\n        if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);\n        return newEvents;\n      }\n\n      var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);\n      if (!node) throw new Error(\"Unable to find segment #\".concat(segment.id, \" \") + \"[\".concat(segment.leftSE.point.x, \", \").concat(segment.leftSE.point.y, \"] -> \") + \"[\".concat(segment.rightSE.point.x, \", \").concat(segment.rightSE.point.y, \"] \") + 'in SweepLine tree. Please submit a bug report.');\n      var prevNode = node;\n      var nextNode = node;\n      var prevSeg = undefined;\n      var nextSeg = undefined; // skip consumed segments still in tree\n\n      while (prevSeg === undefined) {\n        prevNode = this.tree.prev(prevNode);\n        if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;\n      } // skip consumed segments still in tree\n\n\n      while (nextSeg === undefined) {\n        nextNode = this.tree.next(nextNode);\n        if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;\n      }\n\n      if (event.isLeft) {\n        // Check for intersections against the previous segment in the sweep line\n        var prevMySplitter = null;\n\n        if (prevSeg) {\n          var prevInter = prevSeg.getIntersection(segment);\n\n          if (prevInter !== null) {\n            if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;\n\n            if (!prevSeg.isAnEndpoint(prevInter)) {\n              var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);\n\n              for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n                newEvents.push(newEventsFromSplit[i]);\n              }\n            }\n          }\n        } // Check for intersections against the next segment in the sweep line\n\n\n        var nextMySplitter = null;\n\n        if (nextSeg) {\n          var nextInter = nextSeg.getIntersection(segment);\n\n          if (nextInter !== null) {\n            if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;\n\n            if (!nextSeg.isAnEndpoint(nextInter)) {\n              var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);\n\n              for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {\n                newEvents.push(_newEventsFromSplit[_i]);\n              }\n            }\n          }\n        } // For simplicity, even if we find more than one intersection we only\n        // spilt on the 'earliest' (sweep-line style) of the intersections.\n        // The other intersection will be handled in a future process().\n\n\n        if (prevMySplitter !== null || nextMySplitter !== null) {\n          var mySplitter = null;\n          if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {\n            var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);\n            mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;\n          } // Rounding errors can cause changes in ordering,\n          // so remove afected segments and right sweep events before splitting\n\n          this.queue.remove(segment.rightSE);\n          newEvents.push(segment.rightSE);\n\n          var _newEventsFromSplit2 = segment.split(mySplitter);\n\n          for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {\n            newEvents.push(_newEventsFromSplit2[_i2]);\n          }\n        }\n\n        if (newEvents.length > 0) {\n          // We found some intersections, so re-do the current event to\n          // make sure sweep line ordering is totally consistent for later\n          // use with the segment 'prev' pointers\n          this.tree.remove(segment);\n          newEvents.push(event);\n        } else {\n          // done with left event\n          this.segments.push(segment);\n          segment.prev = prevSeg;\n        }\n      } else {\n        // event.isRight\n        // since we're about to be removed from the sweep line, check for\n        // intersections between our previous and next segments\n        if (prevSeg && nextSeg) {\n          var inter = prevSeg.getIntersection(nextSeg);\n\n          if (inter !== null) {\n            if (!prevSeg.isAnEndpoint(inter)) {\n              var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);\n\n              for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {\n                newEvents.push(_newEventsFromSplit3[_i3]);\n              }\n            }\n\n            if (!nextSeg.isAnEndpoint(inter)) {\n              var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);\n\n              for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {\n                newEvents.push(_newEventsFromSplit4[_i4]);\n              }\n            }\n          }\n        }\n\n        this.tree.remove(segment);\n      }\n\n      return newEvents;\n    }\n    /* Safely split a segment that is currently in the datastructures\n     * IE - a segment other than the one that is currently being processed. */\n\n  }, {\n    key: \"_splitSafely\",\n    value: function _splitSafely(seg, pt) {\n      // Rounding errors can cause changes in ordering,\n      // so remove afected segments and right sweep events before splitting\n      // removeNode() doesn't work, so have re-find the seg\n      // https://github.com/w8r/splay-tree/pull/5\n      this.tree.remove(seg);\n      var rightSE = seg.rightSE;\n      this.queue.remove(rightSE);\n      var newEvents = seg.split(pt);\n      newEvents.push(rightSE); // splitting can trigger consumption\n\n      if (seg.consumedBy === undefined) this.tree.insert(seg);\n      return newEvents;\n    }\n  }]);\n\n  return SweepLine;\n}();\n\nvar POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;\nvar POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;\nvar Operation = /*#__PURE__*/function () {\n  function Operation() {\n    _classCallCheck(this, Operation);\n  }\n\n  _createClass(Operation, [{\n    key: \"run\",\n    value: function run(type, geom, moreGeoms) {\n      operation.type = type;\n      rounder.reset();\n      /* Convert inputs to MultiPoly objects */\n\n      var multipolys = [new MultiPolyIn(geom, true)];\n\n      for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n        multipolys.push(new MultiPolyIn(moreGeoms[i], false));\n      }\n\n      operation.numMultiPolys = multipolys.length;\n      /* BBox optimization for difference operation\n       * If the bbox of a multipolygon that's part of the clipping doesn't\n       * intersect the bbox of the subject at all, we can just drop that\n       * multiploygon. */\n\n      if (operation.type === 'difference') {\n        // in place removal\n        var subject = multipolys[0];\n        var _i = 1;\n\n        while (_i < multipolys.length) {\n          if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null) _i++;else multipolys.splice(_i, 1);\n        }\n      }\n      /* BBox optimization for intersection operation\n       * If we can find any pair of multipolygons whose bbox does not overlap,\n       * then the result will be empty. */\n\n\n      if (operation.type === 'intersection') {\n        // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,\n        //       it could be optimized to O(n * ln(n))\n        for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {\n          var mpA = multipolys[_i2];\n\n          for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {\n            if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];\n          }\n        }\n      }\n      /* Put segment endpoints in a priority queue */\n\n\n      var queue = new SplayTree(SweepEvent.compare);\n\n      for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {\n        var sweepEvents = multipolys[_i3].getSweepEvents();\n\n        for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {\n          queue.insert(sweepEvents[_j]);\n\n          if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            throw new Error('Infinite loop when putting segment endpoints in a priority queue ' + '(queue size too big). Please file a bug report.');\n          }\n        }\n      }\n      /* Pass the sweep line over those endpoints */\n\n\n      var sweepLine = new SweepLine(queue);\n      var prevQueueSize = queue.size;\n      var node = queue.pop();\n\n      while (node) {\n        var evt = node.key;\n\n        if (queue.size === prevQueueSize) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          var seg = evt.segment;\n          throw new Error(\"Unable to pop() \".concat(evt.isLeft ? 'left' : 'right', \" SweepEvent \") + \"[\".concat(evt.point.x, \", \").concat(evt.point.y, \"] from segment #\").concat(seg.id, \" \") + \"[\".concat(seg.leftSE.point.x, \", \").concat(seg.leftSE.point.y, \"] -> \") + \"[\".concat(seg.rightSE.point.x, \", \").concat(seg.rightSE.point.y, \"] from queue. \") + 'Please file a bug report.');\n        }\n\n        if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          throw new Error('Infinite loop when passing sweep line over endpoints ' + '(queue size too big). Please file a bug report.');\n        }\n\n        if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          throw new Error('Infinite loop when passing sweep line over endpoints ' + '(too many sweep line segments). Please file a bug report.');\n        }\n\n        var newEvents = sweepLine.process(evt);\n\n        for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {\n          var _evt = newEvents[_i4];\n          if (_evt.consumedBy === undefined) queue.insert(_evt);\n        }\n\n        prevQueueSize = queue.size;\n        node = queue.pop();\n      } // free some memory we don't need anymore\n\n\n      rounder.reset();\n      /* Collect and compile segments we're keeping into a multipolygon */\n\n      var ringsOut = RingOut.factory(sweepLine.segments);\n      var result = new MultiPolyOut(ringsOut);\n      return result.getGeom();\n    }\n  }]);\n\n  return Operation;\n}(); // singleton available by import\n\nvar operation = new Operation();\n\nvar union = function union(geom) {\n  for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    moreGeoms[_key - 1] = arguments[_key];\n  }\n\n  return operation.run('union', geom, moreGeoms);\n};\n\nvar intersection$1 = function intersection(geom) {\n  for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    moreGeoms[_key2 - 1] = arguments[_key2];\n  }\n\n  return operation.run('intersection', geom, moreGeoms);\n};\n\nvar xor = function xor(geom) {\n  for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    moreGeoms[_key3 - 1] = arguments[_key3];\n  }\n\n  return operation.run('xor', geom, moreGeoms);\n};\n\nvar difference = function difference(subjectGeom) {\n  for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    clippingGeoms[_key4 - 1] = arguments[_key4];\n  }\n\n  return operation.run('difference', subjectGeom, clippingGeoms);\n};\n\nvar index = {\n  union: union,\n  intersection: intersection$1,\n  xor: xor,\n  difference: difference\n};\n\nexport default index;\n"],
  "mappings": "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",
  "names": []
}
