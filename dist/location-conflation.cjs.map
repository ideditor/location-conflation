{
  "version": 3,
  "sources": ["../node_modules/@ideditor/country-coder/node_modules/quickselect/quickselect.js", "../node_modules/@ideditor/country-coder/node_modules/rbush/index.js", "../node_modules/@ideditor/country-coder/node_modules/lineclip/index.js", "../node_modules/@ideditor/country-coder/node_modules/which-polygon/index.js", "../node_modules/@ideditor/country-coder/src/country-coder.ts", "../node_modules/wgs84/index.js", "../node_modules/@mapbox/geojson-area/index.js", "../node_modules/circle-to-polygon/index.js", "../node_modules/polygon-clipping/node_modules/splaytree/dist/splay.js", "../node_modules/polygon-clipping/dist/polygon-clipping.cjs.js", "../node_modules/geojson-precision/index.js", "../node_modules/@aitodotai/json-stringify-pretty-compact/index.js", "../index.mjs"],
  "sourcesContent": ["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.quickselect = factory());\n}(this, (function () { 'use strict';\n\nfunction quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nreturn quickselect;\n\n})));\n", "'use strict';\n\nmodule.exports = rbush;\nmodule.exports.default = rbush;\n\nvar quickselect = require('quickselect');\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n", "'use strict';\n\nmodule.exports = lineclip;\n\nlineclip.polyline = lineclip;\nlineclip.polygon = polygonclip;\n\n\n// Cohen-Sutherland line clippign algorithm, adapted to efficiently\n// handle polylines rather than just segments\n\nfunction lineclip(points, bbox, result) {\n\n    var len = points.length,\n        codeA = bitCode(points[0], bbox),\n        part = [],\n        i, a, b, codeB, lastCode;\n\n    if (!result) result = [];\n\n    for (i = 1; i < len; i++) {\n        a = points[i - 1];\n        b = points[i];\n        codeB = lastCode = bitCode(b, bbox);\n\n        while (true) {\n\n            if (!(codeA | codeB)) { // accept\n                part.push(a);\n\n                if (codeB !== lastCode) { // segment went outside\n                    part.push(b);\n\n                    if (i < len - 1) { // start a new line\n                        result.push(part);\n                        part = [];\n                    }\n                } else if (i === len - 1) {\n                    part.push(b);\n                }\n                break;\n\n            } else if (codeA & codeB) { // trivial reject\n                break;\n\n            } else if (codeA) { // a outside, intersect with clip edge\n                a = intersect(a, b, codeA, bbox);\n                codeA = bitCode(a, bbox);\n\n            } else { // b outside\n                b = intersect(a, b, codeB, bbox);\n                codeB = bitCode(b, bbox);\n            }\n        }\n\n        codeA = lastCode;\n    }\n\n    if (part.length) result.push(part);\n\n    return result;\n}\n\n// Sutherland-Hodgeman polygon clipping algorithm\n\nfunction polygonclip(points, bbox) {\n\n    var result, edge, prev, prevInside, i, p, inside;\n\n    // clip against each side of the clip rectangle\n    for (edge = 1; edge <= 8; edge *= 2) {\n        result = [];\n        prev = points[points.length - 1];\n        prevInside = !(bitCode(prev, bbox) & edge);\n\n        for (i = 0; i < points.length; i++) {\n            p = points[i];\n            inside = !(bitCode(p, bbox) & edge);\n\n            // if segment goes through the clip window, add an intersection\n            if (inside !== prevInside) result.push(intersect(prev, p, edge, bbox));\n\n            if (inside) result.push(p); // add a point if it's inside\n\n            prev = p;\n            prevInside = inside;\n        }\n\n        points = result;\n\n        if (!points.length) break;\n    }\n\n    return result;\n}\n\n// intersect a segment against one of the 4 lines that make up the bbox\n\nfunction intersect(a, b, edge, bbox) {\n    return edge & 8 ? [a[0] + (b[0] - a[0]) * (bbox[3] - a[1]) / (b[1] - a[1]), bbox[3]] : // top\n           edge & 4 ? [a[0] + (b[0] - a[0]) * (bbox[1] - a[1]) / (b[1] - a[1]), bbox[1]] : // bottom\n           edge & 2 ? [bbox[2], a[1] + (b[1] - a[1]) * (bbox[2] - a[0]) / (b[0] - a[0])] : // right\n           edge & 1 ? [bbox[0], a[1] + (b[1] - a[1]) * (bbox[0] - a[0]) / (b[0] - a[0])] : // left\n           null;\n}\n\n// bit code reflects the point position relative to the bbox:\n\n//         left  mid  right\n//    top  1001  1000  1010\n//    mid  0001  0000  0010\n// bottom  0101  0100  0110\n\nfunction bitCode(p, bbox) {\n    var code = 0;\n\n    if (p[0] < bbox[0]) code |= 1; // left\n    else if (p[0] > bbox[2]) code |= 2; // right\n\n    if (p[1] < bbox[1]) code |= 4; // bottom\n    else if (p[1] > bbox[3]) code |= 8; // top\n\n    return code;\n}\n", "'use strict';\n\nvar rbush = require('rbush');\nvar lineclip = require('lineclip');\n\nmodule.exports = whichPolygon;\n\nfunction whichPolygon(data) {\n    var bboxes = [];\n    for (var i = 0; i < data.features.length; i++) {\n        var feature = data.features[i];\n        var coords = feature.geometry.coordinates;\n\n        if (feature.geometry.type === 'Polygon') {\n            bboxes.push(treeItem(coords, feature.properties));\n\n        } else if (feature.geometry.type === 'MultiPolygon') {\n            for (var j = 0; j < coords.length; j++) {\n                bboxes.push(treeItem(coords[j], feature.properties));\n            }\n        }\n    }\n\n    var tree = rbush().load(bboxes);\n\n    function query(p, multi) {\n        var output = [],\n            result = tree.search({\n                minX: p[0],\n                minY: p[1],\n                maxX: p[0],\n                maxY: p[1]\n            });\n        for (var i = 0; i < result.length; i++) {\n            if (insidePolygon(result[i].coords, p)) {\n                if (multi)\n                    output.push(result[i].props);\n                else\n                    return result[i].props;\n            }\n        }\n        return multi && output.length ? output : null;\n    }\n\n    query.tree = tree;\n    query.bbox = function queryBBox(bbox) {\n        var output = [];\n        var result = tree.search({\n            minX: bbox[0],\n            minY: bbox[1],\n            maxX: bbox[2],\n            maxY: bbox[3]\n        });\n        for (var i = 0; i < result.length; i++) {\n            if (polygonIntersectsBBox(result[i].coords, bbox)) {\n                output.push(result[i].props);\n            }\n        }\n        return output;\n    };\n\n    return query;\n}\n\nfunction polygonIntersectsBBox(polygon, bbox) {\n    var bboxCenter = [\n        (bbox[0] + bbox[2]) / 2,\n        (bbox[1] + bbox[3]) / 2\n    ];\n    if (insidePolygon(polygon, bboxCenter)) return true;\n    for (var i = 0; i < polygon.length; i++) {\n        if (lineclip(polygon[i], bbox).length > 0) return true;\n    }\n    return false;\n}\n\n// ray casting algorithm for detecting if point is in polygon\nfunction insidePolygon(rings, p) {\n    var inside = false;\n    for (var i = 0, len = rings.length; i < len; i++) {\n        var ring = rings[i];\n        for (var j = 0, len2 = ring.length, k = len2 - 1; j < len2; k = j++) {\n            if (rayIntersect(p, ring[j], ring[k])) inside = !inside;\n        }\n    }\n    return inside;\n}\n\nfunction rayIntersect(p, p1, p2) {\n    return ((p1[1] > p[1]) !== (p2[1] > p[1])) && (p[0] < (p2[0] - p1[0]) * (p[1] - p1[1]) / (p2[1] - p1[1]) + p1[0]);\n}\n\nfunction treeItem(coords, props) {\n    var item = {\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity,\n        coords: coords,\n        props: props\n    };\n\n    for (var i = 0; i < coords[0].length; i++) {\n        var p = coords[0][i];\n        item.minX = Math.min(item.minX, p[0]);\n        item.minY = Math.min(item.minY, p[1]);\n        item.maxX = Math.max(item.maxX, p[0]);\n        item.maxY = Math.max(item.maxY, p[1]);\n    }\n    return item;\n}\n", "import whichPolygon from 'which-polygon';\nimport rawBorders from './data/borders.json';\n\ntype RegionFeatureProperties = {\n  // Unique identifier specific to country-coder\n  id: string;\n\n  // ISO 3166-1 alpha-2 code\n  iso1A2: string | undefined;\n\n  // ISO 3166-1 alpha-3 code\n  iso1A3: string | undefined;\n\n  // ISO 3166-1 numeric-3 code\n  iso1N3: string | undefined;\n\n  // UN M49 code\n  m49: string | undefined;\n\n  // Wikidata QID\n  wikidata: string;\n\n  // The emoji flag sequence derived from this feature's ISO 3166-1 alpha-2 code\n  emojiFlag: string | undefined;\n\n  // The ccTLD (country code top-level domain)\n  ccTLD: string | undefined;\n\n  // The common English name\n  nameEn: string;\n\n  // Additional identifiers which can be used to look up this feature;\n  // these cannot collide with the identifiers for any other feature\n  aliases: Array<string> | undefined;\n\n  // For features entirely within a country, the ISO 3166-1 alpha-2 code for that country\n  country: string | undefined;\n\n  // The ISO 3166-1 alpha-2, M49, or QIDs of other features this feature is entirely within, including its country\n  groups: Array<string>;\n\n  // The ISO 3166-1 alpha-2, M49, or QIDs of other features this feature contains;\n  // the inverse of `groups`\n  members: Array<string> | undefined;\n\n  // The rough geographic type of this feature.\n  // Levels do not necessarily nest cleanly within each other.\n  // - `world`: all features\n\n  // - `unitedNations`: United Nations\n  // - `union`: European Union\n  // - `subunion`: Outermost Regions of the EU, Overseas Countries and Territories of the EU\n\n  // Defined by the UN\n  // - `region`: Africa, Americas, Antarctica, Asia, Europe, Oceania\n  // - `subregion`: Sub-Saharan Africa, North America, Micronesia, etc.\n  // - `intermediateRegion`: Eastern Africa, South America, Channel Islands, etc.\n\n  // - `sharedLandform`: Great Britain, Macaronesia, Mariana Islands, etc.\n  // - `country`: Ethiopia, Brazil, United States, etc.\n  // - `subcountryGroup`\n  // - `territory`: Puerto Rico, Gurnsey, Hong Kong, etc.\n  // - `subterritory`: Sark, Ascension Island, Diego Garcia, etc.\n  level: string;\n\n  // The status of this feature's ISO 3166-1 code(s), if any\n  // - `official`: officially-assigned\n  // - `excRes`: exceptionally-reserved\n  // - `usrAssn`: user-assigned\n  isoStatus: string | undefined;\n\n  // The side of the road that traffic drives on within this feature\n  // - `right`\n  // - `left`\n  driveSide: string | undefined;\n\n  // The unit used for road traffic speeds within this feature\n  // - `mph`: miles per hour\n  // - `km/h`: kilometers per hour\n  roadSpeedUnit: string | undefined;\n\n  // The unit used for road vehicle height restrictions within this feature\n  // - `ft`: feet and inches\n  // - `m`: meters\n  roadHeightUnit: string | undefined;\n\n  // The international calling codes for this feature, sometimes including area codes\n  // e.g. `1`, `1 340`\n  callingCodes: Array<string> | undefined;\n};\ntype RegionFeature = { type: string; geometry: any; properties: RegionFeatureProperties };\ntype RegionFeatureCollection = { type: string; features: Array<RegionFeature> };\ntype Vec2 = [number, number]; // [lon, lat]\ntype Bbox = [number, number, number, number]; // [minLon, minLat, maxLon, maxLat]\ntype PointGeometry = { type: string; coordinates: Vec2 };\ntype PointFeature = { type: string; geometry: PointGeometry; properties: any };\ntype Location = Vec2 | PointGeometry | PointFeature;\ntype CodingOptions = {\n  // For overlapping features, the division level of the one to get. If no feature\n  // exists at the given level, the feature at the next higher level is returned.\n  // See the `level` property of `RegionFeatureProperties` for possible values.\n  level?: string | undefined;\n  // Only a feature at the specified level or lower will be returned.\n  maxLevel?: string | undefined;\n  // Only a feature with the specified property will be returned.\n  withProp?: string | undefined;\n};\n\n// The base GeoJSON feature collection\nexport let borders: RegionFeatureCollection = <RegionFeatureCollection>rawBorders;\n\n// The whichPolygon interface for looking up a feature by point\nlet whichPolygonGetter: any = {};\n// The cache for looking up a feature by identifier\nlet featuresByCode: any = {};\n\n// discard special characters and instances of and/the/of that aren't the only characters\nlet idFilterRegex = /(?=(?!^(and|the|of|el|la|de)$))(\\b(and|the|of|el|la|de)\\b)|[-_ .,'()&[\\]/]/gi;\n\nfunction canonicalID(id: string | null): string {\n  let s = id || '';\n  if (s.charAt(0) === '.') {\n    // skip replace if it leads with a '.' (e.g. a ccTLD like '.de', '.la')\n    return s.toUpperCase();\n  } else {\n    return s.replace(idFilterRegex, '').toUpperCase();\n  }\n}\n\n// Geographic levels, roughly from most to least granular\nlet levels = [\n  'subterritory',\n  'territory',\n  'subcountryGroup',\n  'country',\n  'sharedLandform',\n  'intermediateRegion',\n  'subregion',\n  'region',\n  'subunion',\n  'union',\n  'unitedNations',\n  'world'\n];\n\nloadDerivedDataAndCaches(borders);\n// Loads implicit feature data and the getter index caches\nfunction loadDerivedDataAndCaches(borders) {\n  let identifierProps = ['iso1A2', 'iso1A3', 'm49', 'wikidata', 'emojiFlag', 'ccTLD', 'nameEn'];\n  let geometryFeatures: Array<RegionFeature> = [];\n\n  for (let i in borders.features) {\n    let feature = borders.features[i];\n\n    // generate a unique ID for each feature\n    feature.properties.id =\n      feature.properties.iso1A2 || feature.properties.m49 || feature.properties.wikidata;\n\n    loadM49(feature);\n    loadTLD(feature);\n    loadIsoStatus(feature);\n    loadLevel(feature);\n    loadGroups(feature);\n    loadFlag(feature);\n\n    // cache only after loading derived IDs\n    cacheFeatureByIDs(feature);\n\n    if (feature.geometry) geometryFeatures.push(feature);\n  }\n\n  // must load `members` only after fully loading `featuresByID`\n  for (let i in borders.features) {\n    let feature = borders.features[i];\n    // ensure all groups are listed by their ID\n    feature.properties.groups = feature.properties.groups.map(function (groupID) {\n      return featuresByCode[groupID].properties.id;\n    });\n\n    loadMembersForGroupsOf(feature);\n  }\n\n  for (let i in borders.features) {\n    let feature = borders.features[i];\n\n    // must load attributes only after loading geometry features into `members`\n    loadRoadSpeedUnit(feature);\n    loadRoadHeightUnit(feature);\n    loadDriveSide(feature);\n    loadCallingCodes(feature);\n\n    loadGroupGroups(feature);\n  }\n\n  for (let i in borders.features) {\n    let feature = borders.features[i];\n    // order groups by their `level`\n    feature.properties.groups.sort(function (groupID1, groupID2) {\n      return (\n        levels.indexOf(featuresByCode[groupID1].properties.level) -\n        levels.indexOf(featuresByCode[groupID2].properties.level)\n      );\n    });\n    // order members by their `level` and then by order in borders\n    if (feature.properties.members)\n      feature.properties.members.sort(function (id1, id2) {\n        let diff =\n          levels.indexOf(featuresByCode[id1].properties.level) -\n          levels.indexOf(featuresByCode[id2].properties.level);\n        if (diff === 0) {\n          return (\n            borders.features.indexOf(featuresByCode[id1]) -\n            borders.features.indexOf(featuresByCode[id2])\n          );\n        }\n        return diff;\n      });\n  }\n\n  // whichPolygon doesn't support null geometry even though GeoJSON does\n  let geometryOnlyCollection: RegionFeatureCollection = {\n    type: 'FeatureCollection',\n    features: geometryFeatures\n  };\n  whichPolygonGetter = whichPolygon(geometryOnlyCollection);\n\n  function loadGroups(feature: RegionFeature) {\n    let props = feature.properties;\n    if (!props.groups) {\n      props.groups = [];\n    }\n    if (feature.geometry && props.country) {\n      // Add `country` to `groups`\n      props.groups.push(props.country);\n    }\n    if (props.m49 !== '001') {\n      // all features are in the world feature except the world itself\n      props.groups.push('001');\n    }\n  }\n\n  function loadM49(feature: RegionFeature) {\n    let props = feature.properties;\n    if (!props.m49 && props.iso1N3) {\n      // M49 is a superset of ISO numerics so we only need to store one\n      props.m49 = props.iso1N3;\n    }\n  }\n\n  function loadTLD(feature: RegionFeature) {\n    let props = feature.properties;\n    if (props.level === 'unitedNations') return; // `.un` is not a ccTLD\n    if (!props.ccTLD && props.iso1A2) {\n      // ccTLD is nearly the same as iso1A2, so we only need to explicitly code any exceptions\n      props.ccTLD = '.' + props.iso1A2.toLowerCase();\n    }\n  }\n\n  function loadIsoStatus(feature: RegionFeature) {\n    let props = feature.properties;\n    if (!props.isoStatus && props.iso1A2) {\n      // Features with an ISO code but no explicit status are officially-assigned\n      props.isoStatus = 'official';\n    }\n  }\n\n  function loadLevel(feature: RegionFeature) {\n    let props = feature.properties;\n    if (props.level) return;\n    if (!props.country) {\n      // a feature without an explicit `level` or `country` is itself a country\n      props.level = 'country';\n    } else if (!props.iso1A2 || props.isoStatus === 'official') {\n      props.level = 'territory';\n    } else {\n      props.level = 'subterritory';\n    }\n  }\n\n  function loadGroupGroups(feature: RegionFeature) {\n    let props = feature.properties;\n    if (feature.geometry || !props.members) return;\n    let featureLevelIndex = levels.indexOf(props.level);\n    let sharedGroups: Array<string> = [];\n    for (let i in props.members) {\n      let memberID = props.members[i];\n      let member = featuresByCode[memberID];\n      let memberGroups = member.properties.groups.filter(function (groupID) {\n        return (\n          groupID !== feature.properties.id &&\n          featureLevelIndex < levels.indexOf(featuresByCode[groupID].properties.level)\n        );\n      });\n      if (i === '0') {\n        sharedGroups = memberGroups;\n      } else {\n        sharedGroups = sharedGroups.filter(function (groupID) {\n          return memberGroups.indexOf(groupID) !== -1;\n        });\n      }\n    }\n    props.groups = props.groups.concat(\n      sharedGroups.filter(function (groupID) {\n        return props.groups.indexOf(groupID) === -1;\n      })\n    );\n    for (let j in sharedGroups) {\n      let groupFeature = featuresByCode[sharedGroups[j]];\n      if (groupFeature.properties.members.indexOf(props.id) === -1) {\n        groupFeature.properties.members.push(props.id);\n      }\n    }\n  }\n\n  function loadRoadSpeedUnit(feature: RegionFeature) {\n    let props = feature.properties;\n    if (feature.geometry) {\n      // only `mph` regions are listed explicitly, else assume `km/h`\n      if (!props.roadSpeedUnit) props.roadSpeedUnit = 'km/h';\n    } else if (props.members) {\n      let vals = Array.from(\n        new Set(\n          props.members\n            .map(function (id) {\n              let member = featuresByCode[id];\n              if (member.geometry) return member.properties.roadSpeedUnit || 'km/h';\n            })\n            .filter(Boolean)\n        )\n      );\n      // if all members have the same value then that's also the value for this feature\n      if (vals.length === 1) props.roadSpeedUnit = vals[0];\n    }\n  }\n\n  function loadRoadHeightUnit(feature: RegionFeature) {\n    let props = feature.properties;\n    if (feature.geometry) {\n      // only `ft` regions are listed explicitly, else assume `m`\n      if (!props.roadHeightUnit) props.roadHeightUnit = 'm';\n    } else if (props.members) {\n      let vals = Array.from(\n        new Set(\n          props.members\n            .map(function (id) {\n              let member = featuresByCode[id];\n              if (member.geometry) return member.properties.roadHeightUnit || 'm';\n            })\n            .filter(Boolean)\n        )\n      );\n      // if all members have the same value then that's also the value for this feature\n      if (vals.length === 1) props.roadHeightUnit = vals[0];\n    }\n  }\n\n  function loadDriveSide(feature: RegionFeature) {\n    let props = feature.properties;\n    if (feature.geometry) {\n      // only `left` regions are listed explicitly, else assume `right`\n      if (!props.driveSide) props.driveSide = 'right';\n    } else if (props.members) {\n      let vals = Array.from(\n        new Set(\n          props.members\n            .map(function (id) {\n              let member = featuresByCode[id];\n              if (member.geometry) return member.properties.driveSide || 'right';\n            })\n            .filter(Boolean)\n        )\n      );\n      // if all members have the same value then that's also the value for this feature\n      if (vals.length === 1) props.driveSide = vals[0];\n    }\n  }\n\n  function loadCallingCodes(feature: RegionFeature) {\n    let props = feature.properties;\n    if (!feature.geometry && props.members) {\n      props.callingCodes = Array.from(\n        new Set(\n          props.members.reduce(function (array, id) {\n            let member = featuresByCode[id];\n            if (member.geometry && member.properties.callingCodes)\n              return array.concat(member.properties.callingCodes);\n            return array;\n          }, [])\n        )\n      );\n    }\n  }\n\n  // Calculates the emoji flag sequence from the alpha-2 code (if any) and caches it\n  function loadFlag(feature: RegionFeature) {\n    if (!feature.properties.iso1A2) return;\n    let flag = feature.properties.iso1A2.replace(/./g, function (char: string) {\n      return String.fromCodePoint(<number>char.charCodeAt(0) + 127397);\n    });\n    feature.properties.emojiFlag = flag;\n  }\n\n  // Populate `members` as the inverse relationship of `groups`\n  function loadMembersForGroupsOf(feature: RegionFeature) {\n    for (let j in feature.properties.groups) {\n      let groupID = feature.properties.groups[j];\n      let groupFeature = featuresByCode[groupID];\n\n      if (!groupFeature.properties.members) groupFeature.properties.members = [];\n      groupFeature.properties.members.push(feature.properties.id);\n    }\n  }\n\n  // Caches features by their identifying strings for rapid lookup\n  function cacheFeatureByIDs(feature: RegionFeature) {\n    let ids: Array<string> = [];\n    for (let k in identifierProps) {\n      let prop = identifierProps[k];\n      let id = feature.properties[prop];\n      if (id) ids.push(id);\n    }\n    if (feature.properties.aliases) {\n      for (let j in feature.properties.aliases) {\n        ids.push(feature.properties.aliases[j]);\n      }\n    }\n    for (let i in ids) {\n      let id = canonicalID(ids[i]);\n      featuresByCode[id] = feature;\n    }\n  }\n}\n\n// Returns the [longitude, latitude] for the location argument\nfunction locArray(loc: Location): Vec2 {\n  if (Array.isArray(loc)) {\n    return <Vec2>loc;\n  } else if ((<PointGeometry>loc).coordinates) {\n    return (<PointGeometry>loc).coordinates;\n  }\n  return (<PointFeature>loc).geometry.coordinates;\n}\n\n// Returns the smallest feature of any kind containing `loc`, if any\nfunction smallestFeature(loc: Location): RegionFeature | null {\n  let query = locArray(loc);\n  let featureProperties: RegionFeatureProperties = whichPolygonGetter(query);\n  if (!featureProperties) return null;\n  return featuresByCode[featureProperties.id];\n}\n\n// Returns the country feature containing `loc`, if any\nfunction countryFeature(loc: Location): RegionFeature | null {\n  let feature = smallestFeature(loc);\n  if (!feature) return null;\n  // a feature without `country` but with geometry is itself a country\n  let countryCode = feature.properties.country || feature.properties.iso1A2;\n  return featuresByCode[<string>countryCode] || null;\n}\n\nlet defaultOpts = {\n  level: undefined,\n  maxLevel: undefined,\n  withProp: undefined\n};\n\n// Returns the feature containing `loc` for the `opts`, if any\nfunction featureForLoc(loc: Location, opts: CodingOptions): RegionFeature | null {\n  let targetLevel = opts.level || 'country';\n  let maxLevel = opts.maxLevel || 'world';\n  let withProp = opts.withProp;\n\n  let targetLevelIndex = levels.indexOf(targetLevel);\n  if (targetLevelIndex === -1) return null;\n\n  let maxLevelIndex = levels.indexOf(maxLevel);\n  if (maxLevelIndex === -1) return null;\n  if (maxLevelIndex < targetLevelIndex) return null;\n\n  if (targetLevel === 'country') {\n    // attempt fast path for country-level coding\n    let fastFeature = countryFeature(loc);\n    if (fastFeature) {\n      if (!withProp || fastFeature.properties[withProp]) {\n        return fastFeature;\n      }\n    }\n  }\n\n  let features = featuresContaining(loc);\n\n  for (let i in features) {\n    let feature = features[i];\n    let levelIndex = levels.indexOf(feature.properties.level);\n    if (\n      feature.properties.level === targetLevel ||\n      // if no feature exists at the target level, return the first feature at the next level up\n      (levelIndex > targetLevelIndex && levelIndex <= maxLevelIndex)\n    ) {\n      if (!withProp || feature.properties[withProp]) {\n        return feature;\n      }\n    }\n  }\n  return null;\n}\n\n// Returns the feature with an identifying property matching `id`, if any\nfunction featureForID(id: string | number): RegionFeature | null {\n  let stringID: string;\n\n  if (typeof id === 'number') {\n    stringID = id.toString();\n    if (stringID.length === 1) {\n      stringID = '00' + stringID;\n    } else if (stringID.length === 2) {\n      stringID = '0' + stringID;\n    }\n  } else {\n    stringID = canonicalID(id);\n  }\n  return featuresByCode[stringID] || null;\n}\n\nfunction smallestFeaturesForBbox(bbox: Bbox): [RegionFeature] {\n  return whichPolygonGetter.bbox(bbox).map(function (props) {\n    return featuresByCode[props.id];\n  });\n}\n\nfunction smallestOrMatchingFeature(query: Location | string | number): RegionFeature | null {\n  if (typeof query === 'object') {\n    return smallestFeature(<Location>query);\n  }\n  return featureForID(query);\n}\n\n// Returns the feature matching the given arguments, if any\nexport function feature(\n  query: Location | string | number,\n  opts: CodingOptions = defaultOpts\n): RegionFeature | null {\n  if (typeof query === 'object') {\n    return featureForLoc(<Location>query, opts);\n  }\n  return featureForID(query);\n}\n\n// Returns the ISO 3166-1 alpha-2 code for the feature matching the arguments, if any\nexport function iso1A2Code(\n  query: Location | string | number,\n  opts: CodingOptions = defaultOpts\n): string | null {\n  opts.withProp = 'iso1A2';\n  let match = feature(query, opts);\n  if (!match) return null;\n  return match.properties.iso1A2 || null;\n}\n\n// Returns the ISO 3166-1 alpha-3 code for the feature matching the arguments, if any\nexport function iso1A3Code(\n  query: Location | string | number,\n  opts: CodingOptions = defaultOpts\n): string | null {\n  opts.withProp = 'iso1A3';\n  let match = feature(query, opts);\n  if (!match) return null;\n  return match.properties.iso1A3 || null;\n}\n\n// Returns the ISO 3166-1 numeric-3 code for the feature matching the arguments, if any\nexport function iso1N3Code(\n  query: Location | string | number,\n  opts: CodingOptions = defaultOpts\n): string | null {\n  opts.withProp = 'iso1N3';\n  let match = feature(query, opts);\n  if (!match) return null;\n  return match.properties.iso1N3 || null;\n}\n\n// Returns the UN M49 code for the feature matching the arguments, if any\nexport function m49Code(\n  query: Location | string | number,\n  opts: CodingOptions = defaultOpts\n): string | null {\n  opts.withProp = 'm49';\n  let match = feature(query, opts);\n  if (!match) return null;\n  return match.properties.m49 || null;\n}\n\n// Returns the Wikidata QID code for the feature matching the arguments, if any\nexport function wikidataQID(\n  query: Location | string | number,\n  opts: CodingOptions = defaultOpts\n): string | null {\n  opts.withProp = 'wikidata';\n  let match = feature(query, opts);\n  if (!match) return null;\n  return match.properties.wikidata;\n}\n\n// Returns the emoji emojiFlag sequence for the feature matching the arguments, if any\nexport function emojiFlag(\n  query: Location | string | number,\n  opts: CodingOptions = defaultOpts\n): string | null {\n  opts.withProp = 'emojiFlag';\n  let match = feature(query, opts);\n  if (!match) return null;\n  return match.properties.emojiFlag || null;\n}\n\n// Returns the ccTLD (country code top-level domain) for the feature matching the arguments, if any\nexport function ccTLD(\n  query: Location | string | number,\n  opts: CodingOptions = defaultOpts\n): string | null {\n  opts.withProp = 'ccTLD';\n  let match = feature(query, opts);\n  if (!match) return null;\n  return match.properties.ccTLD || null;\n}\n\nfunction propertiesForQuery(query: Location | Bbox, property: string): Array<string> {\n  let features = featuresContaining(query, false);\n  return features\n    .map(function (feature) {\n      return feature.properties[property];\n    })\n    .filter(Boolean);\n}\n\n// Returns all the ISO 3166-1 alpha-2 codes of features at the location\nexport function iso1A2Codes(query: Location | Bbox): Array<string> {\n  return propertiesForQuery(query, 'iso1A2');\n}\n\n// Returns all the ISO 3166-1 alpha-3 codes of features at the location\nexport function iso1A3Codes(query: Location | Bbox): Array<string> {\n  return propertiesForQuery(query, 'iso1A3');\n}\n\n// Returns all the ISO 3166-1 numeric-3 codes of features at the location\nexport function iso1N3Codes(query: Location | Bbox): Array<string> {\n  return propertiesForQuery(query, 'iso1N3');\n}\n\n// Returns all the UN M49 codes of features at the location\nexport function m49Codes(query: Location | Bbox): Array<string> {\n  return propertiesForQuery(query, 'm49');\n}\n\n// Returns all the Wikidata QIDs of features at the location\nexport function wikidataQIDs(query: Location | Bbox): Array<string> {\n  return propertiesForQuery(query, 'wikidata');\n}\n\n// Returns all the emoji flag sequences of features at the location\nexport function emojiFlags(query: Location | Bbox): Array<string> {\n  return propertiesForQuery(query, 'emojiFlag');\n}\n\n// Returns all the ccTLD (country code top-level domain) sequences of features at the location\nexport function ccTLDs(query: Location | Bbox): Array<string> {\n  return propertiesForQuery(query, 'ccTLD');\n}\n\n// Returns the feature matching `query` and all features containing it, if any.\n// If passing `true` for `strict`, an exact match will not be included\nexport function featuresContaining(\n  query: Location | Bbox | string | number,\n  strict?: boolean\n): Array<RegionFeature> {\n  let matchingFeatures: Array<RegionFeature>;\n\n  if (Array.isArray(query) && query.length === 4) {\n    // check if bounding box\n    matchingFeatures = smallestFeaturesForBbox(<Bbox>query);\n  } else {\n    let smallestOrMatching = smallestOrMatchingFeature(<Location | string | number>query);\n    matchingFeatures = smallestOrMatching ? [smallestOrMatching] : [];\n  }\n\n  if (!matchingFeatures.length) return [];\n\n  let returnFeatures: Array<RegionFeature>;\n\n  if (!strict || typeof query === 'object') {\n    returnFeatures = matchingFeatures.slice();\n  } else {\n    returnFeatures = [];\n  }\n\n  for (let j in matchingFeatures) {\n    let properties = matchingFeatures[j].properties;\n    for (let i in properties.groups) {\n      let groupID = properties.groups[i];\n      let groupFeature = featuresByCode[groupID];\n      if (returnFeatures.indexOf(groupFeature) === -1) {\n        returnFeatures.push(groupFeature);\n      }\n    }\n  }\n  return returnFeatures;\n}\n\n// Returns the feature matching `id` and all features it contains, if any.\n// If passing `true` for `strict`, an exact match will not be included\nexport function featuresIn(id: string | number, strict?: boolean): Array<RegionFeature> {\n  let feature = featureForID(id);\n  if (!feature) return [];\n\n  let features: Array<RegionFeature> = [];\n\n  if (!strict) {\n    features.push(feature);\n  }\n\n  let properties = feature.properties;\n  if (properties.members) {\n    for (let i in properties.members) {\n      let memberID = properties.members[i];\n      features.push(featuresByCode[memberID]);\n    }\n  }\n  return features;\n}\n\n// Returns a new feature with the properties of the feature matching `id`\n// and the combined geometry of all its component features\nexport function aggregateFeature(id: string | number): RegionFeature | null {\n  let features = featuresIn(id, false);\n  if (features.length === 0) return null;\n\n  let aggregateCoordinates = [];\n  for (let i in features) {\n    let feature = features[i];\n    if (\n      feature.geometry &&\n      feature.geometry.type === 'MultiPolygon' &&\n      feature.geometry.coordinates\n    ) {\n      aggregateCoordinates = aggregateCoordinates.concat(feature.geometry.coordinates);\n    }\n  }\n\n  return {\n    type: 'Feature',\n    properties: features[0].properties,\n    geometry: {\n      type: 'MultiPolygon',\n      coordinates: aggregateCoordinates\n    }\n  };\n}\n\n// Returns true if the feature matching `query` is, or is a part of, the feature matching `bounds`\nexport function isIn(query: Location | string | number, bounds: string | number): boolean | null {\n  let queryFeature = smallestOrMatchingFeature(query);\n  let boundsFeature = featureForID(bounds);\n\n  if (!queryFeature || !boundsFeature) return null;\n\n  if (queryFeature.properties.id === boundsFeature.properties.id) return true;\n  return queryFeature.properties.groups.indexOf(boundsFeature.properties.id) !== -1;\n}\n\n// Returns true if the feature matching `query` is within EU jurisdiction\nexport function isInEuropeanUnion(query: Location | string | number): boolean | null {\n  return isIn(query, 'EU');\n}\n\n// Returns true if the feature matching `query` is, or is within, a United Nations member state\nexport function isInUnitedNations(query: Location | string | number): boolean | null {\n  return isIn(query, 'UN');\n}\n\n// Returns the side traffic drives on in the feature matching `query` as a string (`right` or `left`)\nexport function driveSide(query: Location | string | number): string | null {\n  let feature = smallestOrMatchingFeature(query);\n  return (feature && feature.properties.driveSide) || null;\n}\n\n// Returns the road speed unit for the feature matching `query` as a string (`mph` or `km/h`)\nexport function roadSpeedUnit(query: Location | string | number): string | null {\n  let feature = smallestOrMatchingFeature(query);\n  return (feature && feature.properties.roadSpeedUnit) || null;\n}\n\n// Returns the road vehicle height restriction unit for the feature matching `query` as a string (`ft` or `m`)\nexport function roadHeightUnit(query: Location | string | number): string | null {\n  let feature = smallestOrMatchingFeature(query);\n  return (feature && feature.properties.roadHeightUnit) || null;\n}\n\n// Returns the full international calling codes for phone numbers in the feature matching `query`, if any\nexport function callingCodes(query: Location | string | number): Array<string> {\n  let feature = smallestOrMatchingFeature(query);\n  return (feature && feature.properties.callingCodes) || [];\n}\n", "module.exports.RADIUS = 6378137;\nmodule.exports.FLATTENING = 1/298.257223563;\nmodule.exports.POLAR_RADIUS = 6356752.3142;\n", "var wgs84 = require('wgs84');\n\nmodule.exports.geometry = geometry;\nmodule.exports.ring = ringArea;\n\nfunction geometry(_) {\n    var area = 0, i;\n    switch (_.type) {\n        case 'Polygon':\n            return polygonArea(_.coordinates);\n        case 'MultiPolygon':\n            for (i = 0; i < _.coordinates.length; i++) {\n                area += polygonArea(_.coordinates[i]);\n            }\n            return area;\n        case 'Point':\n        case 'MultiPoint':\n        case 'LineString':\n        case 'MultiLineString':\n            return 0;\n        case 'GeometryCollection':\n            for (i = 0; i < _.geometries.length; i++) {\n                area += geometry(_.geometries[i]);\n            }\n            return area;\n    }\n}\n\nfunction polygonArea(coords) {\n    var area = 0;\n    if (coords && coords.length > 0) {\n        area += Math.abs(ringArea(coords[0]));\n        for (var i = 1; i < coords.length; i++) {\n            area -= Math.abs(ringArea(coords[i]));\n        }\n    }\n    return area;\n}\n\n/**\n * Calculate the approximate area of the polygon were it projected onto\n *     the earth.  Note that this area will be positive if ring is oriented\n *     clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n *     Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n *\n * Returns:\n * {float} The approximate signed geodesic area of the polygon in square\n *     meters.\n */\n\nfunction ringArea(coords) {\n    var p1, p2, p3, lowerIndex, middleIndex, upperIndex, i,\n    area = 0,\n    coordsLength = coords.length;\n\n    if (coordsLength > 2) {\n        for (i = 0; i < coordsLength; i++) {\n            if (i === coordsLength - 2) {// i = N-2\n                lowerIndex = coordsLength - 2;\n                middleIndex = coordsLength -1;\n                upperIndex = 0;\n            } else if (i === coordsLength - 1) {// i = N-1\n                lowerIndex = coordsLength - 1;\n                middleIndex = 0;\n                upperIndex = 1;\n            } else { // i = 0 to N-3\n                lowerIndex = i;\n                middleIndex = i+1;\n                upperIndex = i+2;\n            }\n            p1 = coords[lowerIndex];\n            p2 = coords[middleIndex];\n            p3 = coords[upperIndex];\n            area += ( rad(p3[0]) - rad(p1[0]) ) * Math.sin( rad(p2[1]));\n        }\n\n        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;\n    }\n\n    return area;\n}\n\nfunction rad(_) {\n    return _ * Math.PI / 180;\n}", "\"use strict\";\nfunction toRadians(angleInDegrees) {\n  return (angleInDegrees * Math.PI) / 180;\n}\n\nfunction toDegrees(angleInRadians) {\n  return (angleInRadians * 180) / Math.PI;\n}\n\nfunction offset(c1, distance, bearing) {\n  var lat1 = toRadians(c1[1]);\n  var lon1 = toRadians(c1[0]);\n  var dByR = distance / 6378137; // distance divided by 6378137 (radius of the earth) wgs84\n  var lat = Math.asin(\n    Math.sin(lat1) * Math.cos(dByR) +\n      Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing)\n  );\n  var lon =\n    lon1 +\n    Math.atan2(\n      Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),\n      Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat)\n    );\n  return [toDegrees(lon), toDegrees(lat)];\n}\n\nfunction validateCenter(center) {\n  const validCenterLengths = [2, 3];\n  if (!Array.isArray(center) || !validCenterLengths.includes(center.length)) {\n    throw new Error(\"ERROR! Center has to be an array of length two or three\");\n  }\n  const [lng, lat] = center;\n  if (typeof lng !== \"number\" || typeof lat !== \"number\") {\n    throw new Error(\n      `ERROR! Longitude and Latitude has to be numbers but where ${typeof lng} and ${typeof lat}`\n    );\n  }\n  if (lng > 180 || lng < -180) {\n    throw new Error(\n      `ERROR! Longitude has to be between -180 and 180 but was ${lng}`\n    );\n  }\n\n  if (lat > 90 || lat < -90) {\n    throw new Error(\n      `ERROR! Latitude has to be between -90 and 90 but was ${lat}`\n    );\n  }\n}\n\nfunction validateRadius(radius) {\n  if (typeof radius !== \"number\") {\n    throw new Error(\n      `ERROR! Radius has to be a positive number but was: ${typeof radius}`\n    );\n  }\n\n  if (radius <= 0) {\n    throw new Error(\n      `ERROR! Radius has to be a positive number but was: ${radius}`\n    );\n  }\n}\n\nfunction validateNumberOfSegments(numberOfSegments) {\n  if (typeof numberOfSegments !== \"number\" && numberOfSegments !== undefined) {\n    throw new Error(\n      `ERROR! Number of segments has to be a number but was: ${typeof numberOfSegments}`\n    );\n  }\n\n  if (numberOfSegments < 3) {\n    throw new Error(\n      `ERROR! Number of segments has to be at least 3 but was: ${numberOfSegments}`\n    );\n  }\n}\n\nfunction validateInput({ center, radius, numberOfSegments }) {\n  validateCenter(center);\n  validateRadius(radius);\n  validateNumberOfSegments(numberOfSegments);\n}\n\nmodule.exports = function circleToPolygon(center, radius, numberOfSegments) {\n  var n = numberOfSegments ? numberOfSegments : 32;\n\n  // validateInput() throws error on invalid input and do nothing on valid input\n  validateInput({ center, radius, numberOfSegments });\n\n  var coordinates = [];\n  for (var i = 0; i < n; ++i) {\n    coordinates.push(offset(center, radius, (2 * Math.PI * -i) / n));\n  }\n  coordinates.push(coordinates[0]);\n\n  return {\n    type: \"Polygon\",\n    coordinates: [coordinates]\n  };\n};\n", "/**\n * splaytree v3.0.1\n * Fast Splay tree for Node and browser\n *\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n * @preserve\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.SplayTree = factory());\n}(this, (function () { 'use strict';\n\n  var Node = /** @class */ (function () {\r\n      function Node(key, data) {\r\n          this.next = null;\r\n          this.key = key;\r\n          this.data = data;\r\n          this.left = null;\r\n          this.right = null;\r\n      }\r\n      return Node;\r\n  }());\n\n  /* follows \"An implementation of top-down splaying\"\r\n   * by D. Sleator <sleator@cs.cmu.edu> March 1992\r\n   */\r\n  function DEFAULT_COMPARE(a, b) {\r\n      return a > b ? 1 : a < b ? -1 : 0;\r\n  }\r\n  /**\r\n   * Simple top down splay, not requiring i to be in the tree t.\r\n   */\r\n  function splay(i, t, comparator) {\r\n      var N = new Node(null, null);\r\n      var l = N;\r\n      var r = N;\r\n      while (true) {\r\n          var cmp = comparator(i, t.key);\r\n          //if (i < t.key) {\r\n          if (cmp < 0) {\r\n              if (t.left === null)\r\n                  break;\r\n              //if (i < t.left.key) {\r\n              if (comparator(i, t.left.key) < 0) {\r\n                  var y = t.left; /* rotate right */\r\n                  t.left = y.right;\r\n                  y.right = t;\r\n                  t = y;\r\n                  if (t.left === null)\r\n                      break;\r\n              }\r\n              r.left = t; /* link right */\r\n              r = t;\r\n              t = t.left;\r\n              //} else if (i > t.key) {\r\n          }\r\n          else if (cmp > 0) {\r\n              if (t.right === null)\r\n                  break;\r\n              //if (i > t.right.key) {\r\n              if (comparator(i, t.right.key) > 0) {\r\n                  var y = t.right; /* rotate left */\r\n                  t.right = y.left;\r\n                  y.left = t;\r\n                  t = y;\r\n                  if (t.right === null)\r\n                      break;\r\n              }\r\n              l.right = t; /* link left */\r\n              l = t;\r\n              t = t.right;\r\n          }\r\n          else\r\n              break;\r\n      }\r\n      /* assemble */\r\n      l.right = t.left;\r\n      r.left = t.right;\r\n      t.left = N.right;\r\n      t.right = N.left;\r\n      return t;\r\n  }\r\n  function insert(i, data, t, comparator) {\r\n      var node = new Node(i, data);\r\n      if (t === null) {\r\n          node.left = node.right = null;\r\n          return node;\r\n      }\r\n      t = splay(i, t, comparator);\r\n      var cmp = comparator(i, t.key);\r\n      if (cmp < 0) {\r\n          node.left = t.left;\r\n          node.right = t;\r\n          t.left = null;\r\n      }\r\n      else if (cmp >= 0) {\r\n          node.right = t.right;\r\n          node.left = t;\r\n          t.right = null;\r\n      }\r\n      return node;\r\n  }\r\n  function split(key, v, comparator) {\r\n      var left = null;\r\n      var right = null;\r\n      if (v) {\r\n          v = splay(key, v, comparator);\r\n          var cmp = comparator(v.key, key);\r\n          if (cmp === 0) {\r\n              left = v.left;\r\n              right = v.right;\r\n          }\r\n          else if (cmp < 0) {\r\n              right = v.right;\r\n              v.right = null;\r\n              left = v;\r\n          }\r\n          else {\r\n              left = v.left;\r\n              v.left = null;\r\n              right = v;\r\n          }\r\n      }\r\n      return { left: left, right: right };\r\n  }\r\n  function merge(left, right, comparator) {\r\n      if (right === null)\r\n          return left;\r\n      if (left === null)\r\n          return right;\r\n      right = splay(left.key, right, comparator);\r\n      right.left = left;\r\n      return right;\r\n  }\r\n  /**\r\n   * Prints level of the tree\r\n   */\r\n  function printRow(root, prefix, isTail, out, printNode) {\r\n      if (root) {\r\n          out(\"\" + prefix + (isTail ? '\u2514\u2500\u2500 ' : '\u251C\u2500\u2500 ') + printNode(root) + \"\\n\");\r\n          var indent = prefix + (isTail ? '    ' : '\u2502   ');\r\n          if (root.left)\r\n              printRow(root.left, indent, false, out, printNode);\r\n          if (root.right)\r\n              printRow(root.right, indent, true, out, printNode);\r\n      }\r\n  }\r\n  var Tree = /** @class */ (function () {\r\n      function Tree(comparator) {\r\n          if (comparator === void 0) { comparator = DEFAULT_COMPARE; }\r\n          this._root = null;\r\n          this._size = 0;\r\n          this._comparator = comparator;\r\n      }\r\n      /**\r\n       * Inserts a key, allows duplicates\r\n       */\r\n      Tree.prototype.insert = function (key, data) {\r\n          this._size++;\r\n          return this._root = insert(key, data, this._root, this._comparator);\r\n      };\r\n      /**\r\n       * Adds a key, if it is not present in the tree\r\n       */\r\n      Tree.prototype.add = function (key, data) {\r\n          var node = new Node(key, data);\r\n          if (this._root === null) {\r\n              node.left = node.right = null;\r\n              this._size++;\r\n              this._root = node;\r\n          }\r\n          var comparator = this._comparator;\r\n          var t = splay(key, this._root, comparator);\r\n          var cmp = comparator(key, t.key);\r\n          if (cmp === 0)\r\n              this._root = t;\r\n          else {\r\n              if (cmp < 0) {\r\n                  node.left = t.left;\r\n                  node.right = t;\r\n                  t.left = null;\r\n              }\r\n              else if (cmp > 0) {\r\n                  node.right = t.right;\r\n                  node.left = t;\r\n                  t.right = null;\r\n              }\r\n              this._size++;\r\n              this._root = node;\r\n          }\r\n          return this._root;\r\n      };\r\n      /**\r\n       * @param  {Key} key\r\n       * @return {Node|null}\r\n       */\r\n      Tree.prototype.remove = function (key) {\r\n          this._root = this._remove(key, this._root, this._comparator);\r\n      };\r\n      /**\r\n       * Deletes i from the tree if it's there\r\n       */\r\n      Tree.prototype._remove = function (i, t, comparator) {\r\n          var x;\r\n          if (t === null)\r\n              return null;\r\n          t = splay(i, t, comparator);\r\n          var cmp = comparator(i, t.key);\r\n          if (cmp === 0) { /* found it */\r\n              if (t.left === null) {\r\n                  x = t.right;\r\n              }\r\n              else {\r\n                  x = splay(i, t.left, comparator);\r\n                  x.right = t.right;\r\n              }\r\n              this._size--;\r\n              return x;\r\n          }\r\n          return t; /* It wasn't there */\r\n      };\r\n      /**\r\n       * Removes and returns the node with smallest key\r\n       */\r\n      Tree.prototype.pop = function () {\r\n          var node = this._root;\r\n          if (node) {\r\n              while (node.left)\r\n                  node = node.left;\r\n              this._root = splay(node.key, this._root, this._comparator);\r\n              this._root = this._remove(node.key, this._root, this._comparator);\r\n              return { key: node.key, data: node.data };\r\n          }\r\n          return null;\r\n      };\r\n      /**\r\n       * Find without splaying\r\n       */\r\n      Tree.prototype.findStatic = function (key) {\r\n          var current = this._root;\r\n          var compare = this._comparator;\r\n          while (current) {\r\n              var cmp = compare(key, current.key);\r\n              if (cmp === 0)\r\n                  return current;\r\n              else if (cmp < 0)\r\n                  current = current.left;\r\n              else\r\n                  current = current.right;\r\n          }\r\n          return null;\r\n      };\r\n      Tree.prototype.find = function (key) {\r\n          if (this._root) {\r\n              this._root = splay(key, this._root, this._comparator);\r\n              if (this._comparator(key, this._root.key) !== 0)\r\n                  return null;\r\n          }\r\n          return this._root;\r\n      };\r\n      Tree.prototype.contains = function (key) {\r\n          var current = this._root;\r\n          var compare = this._comparator;\r\n          while (current) {\r\n              var cmp = compare(key, current.key);\r\n              if (cmp === 0)\r\n                  return true;\r\n              else if (cmp < 0)\r\n                  current = current.left;\r\n              else\r\n                  current = current.right;\r\n          }\r\n          return false;\r\n      };\r\n      Tree.prototype.forEach = function (visitor, ctx) {\r\n          var current = this._root;\r\n          var Q = []; /* Initialize stack s */\r\n          var done = false;\r\n          while (!done) {\r\n              if (current !== null) {\r\n                  Q.push(current);\r\n                  current = current.left;\r\n              }\r\n              else {\r\n                  if (Q.length !== 0) {\r\n                      current = Q.pop();\r\n                      visitor.call(ctx, current);\r\n                      current = current.right;\r\n                  }\r\n                  else\r\n                      done = true;\r\n              }\r\n          }\r\n          return this;\r\n      };\r\n      /**\r\n       * Walk key range from `low` to `high`. Stops if `fn` returns a value.\r\n       */\r\n      Tree.prototype.range = function (low, high, fn, ctx) {\r\n          var Q = [];\r\n          var compare = this._comparator;\r\n          var node = this._root;\r\n          var cmp;\r\n          while (Q.length !== 0 || node) {\r\n              if (node) {\r\n                  Q.push(node);\r\n                  node = node.left;\r\n              }\r\n              else {\r\n                  node = Q.pop();\r\n                  cmp = compare(node.key, high);\r\n                  if (cmp > 0) {\r\n                      break;\r\n                  }\r\n                  else if (compare(node.key, low) >= 0) {\r\n                      if (fn.call(ctx, node))\r\n                          return this; // stop if smth is returned\r\n                  }\r\n                  node = node.right;\r\n              }\r\n          }\r\n          return this;\r\n      };\r\n      /**\r\n       * Returns array of keys\r\n       */\r\n      Tree.prototype.keys = function () {\r\n          var keys = [];\r\n          this.forEach(function (_a) {\r\n              var key = _a.key;\r\n              return keys.push(key);\r\n          });\r\n          return keys;\r\n      };\r\n      /**\r\n       * Returns array of all the data in the nodes\r\n       */\r\n      Tree.prototype.values = function () {\r\n          var values = [];\r\n          this.forEach(function (_a) {\r\n              var data = _a.data;\r\n              return values.push(data);\r\n          });\r\n          return values;\r\n      };\r\n      Tree.prototype.min = function () {\r\n          if (this._root)\r\n              return this.minNode(this._root).key;\r\n          return null;\r\n      };\r\n      Tree.prototype.max = function () {\r\n          if (this._root)\r\n              return this.maxNode(this._root).key;\r\n          return null;\r\n      };\r\n      Tree.prototype.minNode = function (t) {\r\n          if (t === void 0) { t = this._root; }\r\n          if (t)\r\n              while (t.left)\r\n                  t = t.left;\r\n          return t;\r\n      };\r\n      Tree.prototype.maxNode = function (t) {\r\n          if (t === void 0) { t = this._root; }\r\n          if (t)\r\n              while (t.right)\r\n                  t = t.right;\r\n          return t;\r\n      };\r\n      /**\r\n       * Returns node at given index\r\n       */\r\n      Tree.prototype.at = function (index) {\r\n          var current = this._root;\r\n          var done = false;\r\n          var i = 0;\r\n          var Q = [];\r\n          while (!done) {\r\n              if (current) {\r\n                  Q.push(current);\r\n                  current = current.left;\r\n              }\r\n              else {\r\n                  if (Q.length > 0) {\r\n                      current = Q.pop();\r\n                      if (i === index)\r\n                          return current;\r\n                      i++;\r\n                      current = current.right;\r\n                  }\r\n                  else\r\n                      done = true;\r\n              }\r\n          }\r\n          return null;\r\n      };\r\n      Tree.prototype.next = function (d) {\r\n          var root = this._root;\r\n          var successor = null;\r\n          if (d.right) {\r\n              successor = d.right;\r\n              while (successor.left)\r\n                  successor = successor.left;\r\n              return successor;\r\n          }\r\n          var comparator = this._comparator;\r\n          while (root) {\r\n              var cmp = comparator(d.key, root.key);\r\n              if (cmp === 0)\r\n                  break;\r\n              else if (cmp < 0) {\r\n                  successor = root;\r\n                  root = root.left;\r\n              }\r\n              else\r\n                  root = root.right;\r\n          }\r\n          return successor;\r\n      };\r\n      Tree.prototype.prev = function (d) {\r\n          var root = this._root;\r\n          var predecessor = null;\r\n          if (d.left !== null) {\r\n              predecessor = d.left;\r\n              while (predecessor.right)\r\n                  predecessor = predecessor.right;\r\n              return predecessor;\r\n          }\r\n          var comparator = this._comparator;\r\n          while (root) {\r\n              var cmp = comparator(d.key, root.key);\r\n              if (cmp === 0)\r\n                  break;\r\n              else if (cmp < 0)\r\n                  root = root.left;\r\n              else {\r\n                  predecessor = root;\r\n                  root = root.right;\r\n              }\r\n          }\r\n          return predecessor;\r\n      };\r\n      Tree.prototype.clear = function () {\r\n          this._root = null;\r\n          this._size = 0;\r\n          return this;\r\n      };\r\n      Tree.prototype.toList = function () {\r\n          return toList(this._root);\r\n      };\r\n      /**\r\n       * Bulk-load items. Both array have to be same size\r\n       */\r\n      Tree.prototype.load = function (keys, values, presort) {\r\n          if (values === void 0) { values = []; }\r\n          if (presort === void 0) { presort = false; }\r\n          var size = keys.length;\r\n          var comparator = this._comparator;\r\n          // sort if needed\r\n          if (presort)\r\n              sort(keys, values, 0, size - 1, comparator);\r\n          if (this._root === null) { // empty tree\r\n              this._root = loadRecursive(keys, values, 0, size);\r\n              this._size = size;\r\n          }\r\n          else { // that re-builds the whole tree from two in-order traversals\r\n              var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\r\n              size = this._size + size;\r\n              this._root = sortedListToBST({ head: mergedList }, 0, size);\r\n          }\r\n          return this;\r\n      };\r\n      Tree.prototype.isEmpty = function () { return this._root === null; };\r\n      Object.defineProperty(Tree.prototype, \"size\", {\r\n          get: function () { return this._size; },\r\n          enumerable: true,\r\n          configurable: true\r\n      });\r\n      Object.defineProperty(Tree.prototype, \"root\", {\r\n          get: function () { return this._root; },\r\n          enumerable: true,\r\n          configurable: true\r\n      });\r\n      Tree.prototype.toString = function (printNode) {\r\n          if (printNode === void 0) { printNode = function (n) { return String(n.key); }; }\r\n          var out = [];\r\n          printRow(this._root, '', true, function (v) { return out.push(v); }, printNode);\r\n          return out.join('');\r\n      };\r\n      Tree.prototype.update = function (key, newKey, newData) {\r\n          var comparator = this._comparator;\r\n          var _a = split(key, this._root, comparator), left = _a.left, right = _a.right;\r\n          if (comparator(key, newKey) < 0) {\r\n              right = insert(newKey, newData, right, comparator);\r\n          }\r\n          else {\r\n              left = insert(newKey, newData, left, comparator);\r\n          }\r\n          this._root = merge(left, right, comparator);\r\n      };\r\n      Tree.prototype.split = function (key) {\r\n          return split(key, this._root, this._comparator);\r\n      };\r\n      return Tree;\r\n  }());\r\n  function loadRecursive(keys, values, start, end) {\r\n      var size = end - start;\r\n      if (size > 0) {\r\n          var middle = start + Math.floor(size / 2);\r\n          var key = keys[middle];\r\n          var data = values[middle];\r\n          var node = new Node(key, data);\r\n          node.left = loadRecursive(keys, values, start, middle);\r\n          node.right = loadRecursive(keys, values, middle + 1, end);\r\n          return node;\r\n      }\r\n      return null;\r\n  }\r\n  function createList(keys, values) {\r\n      var head = new Node(null, null);\r\n      var p = head;\r\n      for (var i = 0; i < keys.length; i++) {\r\n          p = p.next = new Node(keys[i], values[i]);\r\n      }\r\n      p.next = null;\r\n      return head.next;\r\n  }\r\n  function toList(root) {\r\n      var current = root;\r\n      var Q = [];\r\n      var done = false;\r\n      var head = new Node(null, null);\r\n      var p = head;\r\n      while (!done) {\r\n          if (current) {\r\n              Q.push(current);\r\n              current = current.left;\r\n          }\r\n          else {\r\n              if (Q.length > 0) {\r\n                  current = p = p.next = Q.pop();\r\n                  current = current.right;\r\n              }\r\n              else\r\n                  done = true;\r\n          }\r\n      }\r\n      p.next = null; // that'll work even if the tree was empty\r\n      return head.next;\r\n  }\r\n  function sortedListToBST(list, start, end) {\r\n      var size = end - start;\r\n      if (size > 0) {\r\n          var middle = start + Math.floor(size / 2);\r\n          var left = sortedListToBST(list, start, middle);\r\n          var root = list.head;\r\n          root.left = left;\r\n          list.head = list.head.next;\r\n          root.right = sortedListToBST(list, middle + 1, end);\r\n          return root;\r\n      }\r\n      return null;\r\n  }\r\n  function mergeLists(l1, l2, compare) {\r\n      var head = new Node(null, null); // dummy\r\n      var p = head;\r\n      var p1 = l1;\r\n      var p2 = l2;\r\n      while (p1 !== null && p2 !== null) {\r\n          if (compare(p1.key, p2.key) < 0) {\r\n              p.next = p1;\r\n              p1 = p1.next;\r\n          }\r\n          else {\r\n              p.next = p2;\r\n              p2 = p2.next;\r\n          }\r\n          p = p.next;\r\n      }\r\n      if (p1 !== null) {\r\n          p.next = p1;\r\n      }\r\n      else if (p2 !== null) {\r\n          p.next = p2;\r\n      }\r\n      return head.next;\r\n  }\r\n  function sort(keys, values, left, right, compare) {\r\n      if (left >= right)\r\n          return;\r\n      var pivot = keys[(left + right) >> 1];\r\n      var i = left - 1;\r\n      var j = right + 1;\r\n      while (true) {\r\n          do\r\n              i++;\r\n          while (compare(keys[i], pivot) < 0);\r\n          do\r\n              j--;\r\n          while (compare(keys[j], pivot) > 0);\r\n          if (i >= j)\r\n              break;\r\n          var tmp = keys[i];\r\n          keys[i] = keys[j];\r\n          keys[j] = tmp;\r\n          tmp = values[i];\r\n          values[i] = values[j];\r\n          values[j] = tmp;\r\n      }\r\n      sort(keys, values, left, j, compare);\r\n      sort(keys, values, j + 1, right, compare);\r\n  }\n\n  return Tree;\n\n})));\n//# sourceMappingURL=splay.js.map\n", "'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar SplayTree = _interopDefault(require('splaytree'));\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n/**\n * A bounding box has the format:\n *\n *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n *\n */\nvar isInBbox = function isInBbox(bbox, point) {\n  return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;\n};\n/* Returns either null, or a bbox (aka an ordered pair of points)\n * If there is only one point of overlap, a bbox with identical points\n * will be returned */\n\nvar getBboxOverlap = function getBboxOverlap(b1, b2) {\n  // check if the bboxes overlap at all\n  if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null; // find the middle two X values\n\n  var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;\n  var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x; // find the middle two Y values\n\n  var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;\n  var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y; // put those middle values together to get the overlap\n\n  return {\n    ll: {\n      x: lowerX,\n      y: lowerY\n    },\n    ur: {\n      x: upperX,\n      y: upperY\n    }\n  };\n};\n\n/* Javascript doesn't do integer math. Everything is\n * floating point with percision Number.EPSILON.\n *\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n */\nvar epsilon = Number.EPSILON; // IE Polyfill\n\nif (epsilon === undefined) epsilon = Math.pow(2, -52);\nvar EPSILON_SQ = epsilon * epsilon;\n/* FLP comparator */\n\nvar cmp = function cmp(a, b) {\n  // check if they're both 0\n  if (-epsilon < a && a < epsilon) {\n    if (-epsilon < b && b < epsilon) {\n      return 0;\n    }\n  } // check if they're flp equal\n\n\n  var ab = a - b;\n\n  if (ab * ab < EPSILON_SQ * a * b) {\n    return 0;\n  } // normal comparison\n\n\n  return a < b ? -1 : 1;\n};\n\n/**\n * This class rounds incoming values sufficiently so that\n * floating points problems are, for the most part, avoided.\n *\n * Incoming points are have their x & y values tested against\n * all previously seen x & y values. If either is 'too close'\n * to a previously seen value, it's value is 'snapped' to the\n * previously seen value.\n *\n * All points should be rounded by this class before being\n * stored in any data structures in the rest of this algorithm.\n */\n\nvar PtRounder = /*#__PURE__*/function () {\n  function PtRounder() {\n    _classCallCheck(this, PtRounder);\n\n    this.reset();\n  }\n\n  _createClass(PtRounder, [{\n    key: \"reset\",\n    value: function reset() {\n      this.xRounder = new CoordRounder();\n      this.yRounder = new CoordRounder();\n    }\n  }, {\n    key: \"round\",\n    value: function round(x, y) {\n      return {\n        x: this.xRounder.round(x),\n        y: this.yRounder.round(y)\n      };\n    }\n  }]);\n\n  return PtRounder;\n}();\n\nvar CoordRounder = /*#__PURE__*/function () {\n  function CoordRounder() {\n    _classCallCheck(this, CoordRounder);\n\n    this.tree = new SplayTree(); // preseed with 0 so we don't end up with values < Number.EPSILON\n\n    this.round(0);\n  } // Note: this can rounds input values backwards or forwards.\n  //       You might ask, why not restrict this to just rounding\n  //       forwards? Wouldn't that allow left endpoints to always\n  //       remain left endpoints during splitting (never change to\n  //       right). No - it wouldn't, because we snap intersections\n  //       to endpoints (to establish independence from the segment\n  //       angle for t-intersections).\n\n\n  _createClass(CoordRounder, [{\n    key: \"round\",\n    value: function round(coord) {\n      var node = this.tree.add(coord);\n      var prevNode = this.tree.prev(node);\n\n      if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {\n        this.tree.remove(coord);\n        return prevNode.key;\n      }\n\n      var nextNode = this.tree.next(node);\n\n      if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {\n        this.tree.remove(coord);\n        return nextNode.key;\n      }\n\n      return coord;\n    }\n  }]);\n\n  return CoordRounder;\n}(); // singleton available by import\n\n\nvar rounder = new PtRounder();\n\n/* Cross Product of two vectors with first point at origin */\n\nvar crossProduct = function crossProduct(a, b) {\n  return a.x * b.y - a.y * b.x;\n};\n/* Dot Product of two vectors with first point at origin */\n\nvar dotProduct = function dotProduct(a, b) {\n  return a.x * b.x + a.y * b.y;\n};\n/* Comparator for two vectors with same starting point */\n\nvar compareVectorAngles = function compareVectorAngles(basePt, endPt1, endPt2) {\n  var v1 = {\n    x: endPt1.x - basePt.x,\n    y: endPt1.y - basePt.y\n  };\n  var v2 = {\n    x: endPt2.x - basePt.x,\n    y: endPt2.y - basePt.y\n  };\n  var kross = crossProduct(v1, v2);\n  return cmp(kross, 0);\n};\nvar length = function length(v) {\n  return Math.sqrt(dotProduct(v, v));\n};\n/* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\n\nvar sineOfAngle = function sineOfAngle(pShared, pBase, pAngle) {\n  var vBase = {\n    x: pBase.x - pShared.x,\n    y: pBase.y - pShared.y\n  };\n  var vAngle = {\n    x: pAngle.x - pShared.x,\n    y: pAngle.y - pShared.y\n  };\n  return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n/* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\n\nvar cosineOfAngle = function cosineOfAngle(pShared, pBase, pAngle) {\n  var vBase = {\n    x: pBase.x - pShared.x,\n    y: pBase.y - pShared.y\n  };\n  var vAngle = {\n    x: pAngle.x - pShared.x,\n    y: pAngle.y - pShared.y\n  };\n  return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n/* Get the x coordinate where the given line (defined by a point and vector)\n * crosses the horizontal line with the given y coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\n\nvar horizontalIntersection = function horizontalIntersection(pt, v, y) {\n  if (v.y === 0) return null;\n  return {\n    x: pt.x + v.x / v.y * (y - pt.y),\n    y: y\n  };\n};\n/* Get the y coordinate where the given line (defined by a point and vector)\n * crosses the vertical line with the given x coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\n\nvar verticalIntersection = function verticalIntersection(pt, v, x) {\n  if (v.x === 0) return null;\n  return {\n    x: x,\n    y: pt.y + v.y / v.x * (x - pt.x)\n  };\n};\n/* Get the intersection of two lines, each defined by a base point and a vector.\n * In the case of parrallel lines (including overlapping ones) returns null. */\n\nvar intersection = function intersection(pt1, v1, pt2, v2) {\n  // take some shortcuts for vertical and horizontal lines\n  // this also ensures we don't calculate an intersection and then discover\n  // it's actually outside the bounding box of the line\n  if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);\n  if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);\n  if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);\n  if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y); // General case for non-overlapping segments.\n  // This algorithm is based on Schneider and Eberly.\n  // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n  var kross = crossProduct(v1, v2);\n  if (kross == 0) return null;\n  var ve = {\n    x: pt2.x - pt1.x,\n    y: pt2.y - pt1.y\n  };\n  var d1 = crossProduct(ve, v1) / kross;\n  var d2 = crossProduct(ve, v2) / kross; // take the average of the two calculations to minimize rounding error\n\n  var x1 = pt1.x + d2 * v1.x,\n      x2 = pt2.x + d1 * v2.x;\n  var y1 = pt1.y + d2 * v1.y,\n      y2 = pt2.y + d1 * v2.y;\n  var x = (x1 + x2) / 2;\n  var y = (y1 + y2) / 2;\n  return {\n    x: x,\n    y: y\n  };\n};\n\nvar SweepEvent = /*#__PURE__*/function () {\n  _createClass(SweepEvent, null, [{\n    key: \"compare\",\n    // for ordering sweep events in the sweep event queue\n    value: function compare(a, b) {\n      // favor event with a point that the sweep line hits first\n      var ptCmp = SweepEvent.comparePoints(a.point, b.point);\n      if (ptCmp !== 0) return ptCmp; // the points are the same, so link them if needed\n\n      if (a.point !== b.point) a.link(b); // favor right events over left\n\n      if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1; // we have two matching left or right endpoints\n      // ordering of this case is the same as for their segments\n\n      return Segment.compare(a.segment, b.segment);\n    } // for ordering points in sweep line order\n\n  }, {\n    key: \"comparePoints\",\n    value: function comparePoints(aPt, bPt) {\n      if (aPt.x < bPt.x) return -1;\n      if (aPt.x > bPt.x) return 1;\n      if (aPt.y < bPt.y) return -1;\n      if (aPt.y > bPt.y) return 1;\n      return 0;\n    } // Warning: 'point' input will be modified and re-used (for performance)\n\n  }]);\n\n  function SweepEvent(point, isLeft) {\n    _classCallCheck(this, SweepEvent);\n\n    if (point.events === undefined) point.events = [this];else point.events.push(this);\n    this.point = point;\n    this.isLeft = isLeft; // this.segment, this.otherSE set by factory\n  }\n\n  _createClass(SweepEvent, [{\n    key: \"link\",\n    value: function link(other) {\n      if (other.point === this.point) {\n        throw new Error('Tried to link already linked events');\n      }\n\n      var otherEvents = other.point.events;\n\n      for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {\n        var evt = otherEvents[i];\n        this.point.events.push(evt);\n        evt.point = this.point;\n      }\n\n      this.checkForConsuming();\n    }\n    /* Do a pass over our linked events and check to see if any pair\n     * of segments match, and should be consumed. */\n\n  }, {\n    key: \"checkForConsuming\",\n    value: function checkForConsuming() {\n      // FIXME: The loops in this method run O(n^2) => no good.\n      //        Maintain little ordered sweep event trees?\n      //        Can we maintaining an ordering that avoids the need\n      //        for the re-sorting with getLeftmostComparator in geom-out?\n      // Compare each pair of events to see if other events also match\n      var numEvents = this.point.events.length;\n\n      for (var i = 0; i < numEvents; i++) {\n        var evt1 = this.point.events[i];\n        if (evt1.segment.consumedBy !== undefined) continue;\n\n        for (var j = i + 1; j < numEvents; j++) {\n          var evt2 = this.point.events[j];\n          if (evt2.consumedBy !== undefined) continue;\n          if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;\n          evt1.segment.consume(evt2.segment);\n        }\n      }\n    }\n  }, {\n    key: \"getAvailableLinkedEvents\",\n    value: function getAvailableLinkedEvents() {\n      // point.events is always of length 2 or greater\n      var events = [];\n\n      for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {\n        var evt = this.point.events[i];\n\n        if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n          events.push(evt);\n        }\n      }\n\n      return events;\n    }\n    /**\n     * Returns a comparator function for sorting linked events that will\n     * favor the event that will give us the smallest left-side angle.\n     * All ring construction starts as low as possible heading to the right,\n     * so by always turning left as sharp as possible we'll get polygons\n     * without uncessary loops & holes.\n     *\n     * The comparator function has a compute cache such that it avoids\n     * re-computing already-computed values.\n     */\n\n  }, {\n    key: \"getLeftmostComparator\",\n    value: function getLeftmostComparator(baseEvent) {\n      var _this = this;\n\n      var cache = new Map();\n\n      var fillCache = function fillCache(linkedEvent) {\n        var nextEvent = linkedEvent.otherSE;\n        cache.set(linkedEvent, {\n          sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),\n          cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)\n        });\n      };\n\n      return function (a, b) {\n        if (!cache.has(a)) fillCache(a);\n        if (!cache.has(b)) fillCache(b);\n\n        var _cache$get = cache.get(a),\n            asine = _cache$get.sine,\n            acosine = _cache$get.cosine;\n\n        var _cache$get2 = cache.get(b),\n            bsine = _cache$get2.sine,\n            bcosine = _cache$get2.cosine; // both on or above x-axis\n\n\n        if (asine >= 0 && bsine >= 0) {\n          if (acosine < bcosine) return 1;\n          if (acosine > bcosine) return -1;\n          return 0;\n        } // both below x-axis\n\n\n        if (asine < 0 && bsine < 0) {\n          if (acosine < bcosine) return -1;\n          if (acosine > bcosine) return 1;\n          return 0;\n        } // one above x-axis, one below\n\n\n        if (bsine < asine) return -1;\n        if (bsine > asine) return 1;\n        return 0;\n      };\n    }\n  }]);\n\n  return SweepEvent;\n}();\n\n// segments and sweep events when all else is identical\n\nvar segmentId = 0;\n\nvar Segment = /*#__PURE__*/function () {\n  _createClass(Segment, null, [{\n    key: \"compare\",\n\n    /* This compare() function is for ordering segments in the sweep\n     * line tree, and does so according to the following criteria:\n     *\n     * Consider the vertical line that lies an infinestimal step to the\n     * right of the right-more of the two left endpoints of the input\n     * segments. Imagine slowly moving a point up from negative infinity\n     * in the increasing y direction. Which of the two segments will that\n     * point intersect first? That segment comes 'before' the other one.\n     *\n     * If neither segment would be intersected by such a line, (if one\n     * or more of the segments are vertical) then the line to be considered\n     * is directly on the right-more of the two left inputs.\n     */\n    value: function compare(a, b) {\n      var alx = a.leftSE.point.x;\n      var blx = b.leftSE.point.x;\n      var arx = a.rightSE.point.x;\n      var brx = b.rightSE.point.x; // check if they're even in the same vertical plane\n\n      if (brx < alx) return 1;\n      if (arx < blx) return -1;\n      var aly = a.leftSE.point.y;\n      var bly = b.leftSE.point.y;\n      var ary = a.rightSE.point.y;\n      var bry = b.rightSE.point.y; // is left endpoint of segment B the right-more?\n\n      if (alx < blx) {\n        // are the two segments in the same horizontal plane?\n        if (bly < aly && bly < ary) return 1;\n        if (bly > aly && bly > ary) return -1; // is the B left endpoint colinear to segment A?\n\n        var aCmpBLeft = a.comparePoint(b.leftSE.point);\n        if (aCmpBLeft < 0) return 1;\n        if (aCmpBLeft > 0) return -1; // is the A right endpoint colinear to segment B ?\n\n        var bCmpARight = b.comparePoint(a.rightSE.point);\n        if (bCmpARight !== 0) return bCmpARight; // colinear segments, consider the one with left-more\n        // left endpoint to be first (arbitrary?)\n\n        return -1;\n      } // is left endpoint of segment A the right-more?\n\n\n      if (alx > blx) {\n        if (aly < bly && aly < bry) return -1;\n        if (aly > bly && aly > bry) return 1; // is the A left endpoint colinear to segment B?\n\n        var bCmpALeft = b.comparePoint(a.leftSE.point);\n        if (bCmpALeft !== 0) return bCmpALeft; // is the B right endpoint colinear to segment A?\n\n        var aCmpBRight = a.comparePoint(b.rightSE.point);\n        if (aCmpBRight < 0) return 1;\n        if (aCmpBRight > 0) return -1; // colinear segments, consider the one with left-more\n        // left endpoint to be first (arbitrary?)\n\n        return 1;\n      } // if we get here, the two left endpoints are in the same\n      // vertical plane, ie alx === blx\n      // consider the lower left-endpoint to come first\n\n\n      if (aly < bly) return -1;\n      if (aly > bly) return 1; // left endpoints are identical\n      // check for colinearity by using the left-more right endpoint\n      // is the A right endpoint more left-more?\n\n      if (arx < brx) {\n        var _bCmpARight = b.comparePoint(a.rightSE.point);\n\n        if (_bCmpARight !== 0) return _bCmpARight;\n      } // is the B right endpoint more left-more?\n\n\n      if (arx > brx) {\n        var _aCmpBRight = a.comparePoint(b.rightSE.point);\n\n        if (_aCmpBRight < 0) return 1;\n        if (_aCmpBRight > 0) return -1;\n      }\n\n      if (arx !== brx) {\n        // are these two [almost] vertical segments with opposite orientation?\n        // if so, the one with the lower right endpoint comes first\n        var ay = ary - aly;\n        var ax = arx - alx;\n        var by = bry - bly;\n        var bx = brx - blx;\n        if (ay > ax && by < bx) return 1;\n        if (ay < ax && by > bx) return -1;\n      } // we have colinear segments with matching orientation\n      // consider the one with more left-more right endpoint to be first\n\n\n      if (arx > brx) return 1;\n      if (arx < brx) return -1; // if we get here, two two right endpoints are in the same\n      // vertical plane, ie arx === brx\n      // consider the lower right-endpoint to come first\n\n      if (ary < bry) return -1;\n      if (ary > bry) return 1; // right endpoints identical as well, so the segments are idential\n      // fall back on creation order as consistent tie-breaker\n\n      if (a.id < b.id) return -1;\n      if (a.id > b.id) return 1; // identical segment, ie a === b\n\n      return 0;\n    }\n    /* Warning: a reference to ringWindings input will be stored,\n     *  and possibly will be later modified */\n\n  }]);\n\n  function Segment(leftSE, rightSE, rings, windings) {\n    _classCallCheck(this, Segment);\n\n    this.id = ++segmentId;\n    this.leftSE = leftSE;\n    leftSE.segment = this;\n    leftSE.otherSE = rightSE;\n    this.rightSE = rightSE;\n    rightSE.segment = this;\n    rightSE.otherSE = leftSE;\n    this.rings = rings;\n    this.windings = windings; // left unset for performance, set later in algorithm\n    // this.ringOut, this.consumedBy, this.prev\n  }\n\n  _createClass(Segment, [{\n    key: \"replaceRightSE\",\n\n    /* When a segment is split, the rightSE is replaced with a new sweep event */\n    value: function replaceRightSE(newRightSE) {\n      this.rightSE = newRightSE;\n      this.rightSE.segment = this;\n      this.rightSE.otherSE = this.leftSE;\n      this.leftSE.otherSE = this.rightSE;\n    }\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      var y1 = this.leftSE.point.y;\n      var y2 = this.rightSE.point.y;\n      return {\n        ll: {\n          x: this.leftSE.point.x,\n          y: y1 < y2 ? y1 : y2\n        },\n        ur: {\n          x: this.rightSE.point.x,\n          y: y1 > y2 ? y1 : y2\n        }\n      };\n    }\n    /* A vector from the left point to the right */\n\n  }, {\n    key: \"vector\",\n    value: function vector() {\n      return {\n        x: this.rightSE.point.x - this.leftSE.point.x,\n        y: this.rightSE.point.y - this.leftSE.point.y\n      };\n    }\n  }, {\n    key: \"isAnEndpoint\",\n    value: function isAnEndpoint(pt) {\n      return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;\n    }\n    /* Compare this segment with a point.\n     *\n     * A point P is considered to be colinear to a segment if there\n     * exists a distance D such that if we travel along the segment\n     * from one * endpoint towards the other a distance D, we find\n     * ourselves at point P.\n     *\n     * Return value indicates:\n     *\n     *   1: point lies above the segment (to the left of vertical)\n     *   0: point is colinear to segment\n     *  -1: point lies below the segment (to the right of vertical)\n     */\n\n  }, {\n    key: \"comparePoint\",\n    value: function comparePoint(point) {\n      if (this.isAnEndpoint(point)) return 0;\n      var lPt = this.leftSE.point;\n      var rPt = this.rightSE.point;\n      var v = this.vector(); // Exactly vertical segments.\n\n      if (lPt.x === rPt.x) {\n        if (point.x === lPt.x) return 0;\n        return point.x < lPt.x ? 1 : -1;\n      } // Nearly vertical segments with an intersection.\n      // Check to see where a point on the line with matching Y coordinate is.\n\n\n      var yDist = (point.y - lPt.y) / v.y;\n      var xFromYDist = lPt.x + yDist * v.x;\n      if (point.x === xFromYDist) return 0; // General case.\n      // Check to see where a point on the line with matching X coordinate is.\n\n      var xDist = (point.x - lPt.x) / v.x;\n      var yFromXDist = lPt.y + xDist * v.y;\n      if (point.y === yFromXDist) return 0;\n      return point.y < yFromXDist ? -1 : 1;\n    }\n    /**\n     * Given another segment, returns the first non-trivial intersection\n     * between the two segments (in terms of sweep line ordering), if it exists.\n     *\n     * A 'non-trivial' intersection is one that will cause one or both of the\n     * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n     *\n     *   * endpoint of segA with endpoint of segB --> trivial\n     *   * endpoint of segA with point along segB --> non-trivial\n     *   * endpoint of segB with point along segA --> non-trivial\n     *   * point along segA with point along segB --> non-trivial\n     *\n     * If no non-trivial intersection exists, return null\n     * Else, return null.\n     */\n\n  }, {\n    key: \"getIntersection\",\n    value: function getIntersection(other) {\n      // If bboxes don't overlap, there can't be any intersections\n      var tBbox = this.bbox();\n      var oBbox = other.bbox();\n      var bboxOverlap = getBboxOverlap(tBbox, oBbox);\n      if (bboxOverlap === null) return null; // We first check to see if the endpoints can be considered intersections.\n      // This will 'snap' intersections to endpoints if possible, and will\n      // handle cases of colinearity.\n\n      var tlp = this.leftSE.point;\n      var trp = this.rightSE.point;\n      var olp = other.leftSE.point;\n      var orp = other.rightSE.point; // does each endpoint touch the other segment?\n      // note that we restrict the 'touching' definition to only allow segments\n      // to touch endpoints that lie forward from where we are in the sweep line pass\n\n      var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;\n      var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;\n      var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;\n      var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0; // do left endpoints match?\n\n      if (touchesThisLSE && touchesOtherLSE) {\n        // these two cases are for colinear segments with matching left\n        // endpoints, and one segment being longer than the other\n        if (touchesThisRSE && !touchesOtherRSE) return trp;\n        if (!touchesThisRSE && touchesOtherRSE) return orp; // either the two segments match exactly (two trival intersections)\n        // or just on their left endpoint (one trivial intersection\n\n        return null;\n      } // does this left endpoint matches (other doesn't)\n\n\n      if (touchesThisLSE) {\n        // check for segments that just intersect on opposing endpoints\n        if (touchesOtherRSE) {\n          if (tlp.x === orp.x && tlp.y === orp.y) return null;\n        } // t-intersection on left endpoint\n\n\n        return tlp;\n      } // does other left endpoint matches (this doesn't)\n\n\n      if (touchesOtherLSE) {\n        // check for segments that just intersect on opposing endpoints\n        if (touchesThisRSE) {\n          if (trp.x === olp.x && trp.y === olp.y) return null;\n        } // t-intersection on left endpoint\n\n\n        return olp;\n      } // trivial intersection on right endpoints\n\n\n      if (touchesThisRSE && touchesOtherRSE) return null; // t-intersections on just one right endpoint\n\n      if (touchesThisRSE) return trp;\n      if (touchesOtherRSE) return orp; // None of our endpoints intersect. Look for a general intersection between\n      // infinite lines laid over the segments\n\n      var pt = intersection(tlp, this.vector(), olp, other.vector()); // are the segments parrallel? Note that if they were colinear with overlap,\n      // they would have an endpoint intersection and that case was already handled above\n\n      if (pt === null) return null; // is the intersection found between the lines not on the segments?\n\n      if (!isInBbox(bboxOverlap, pt)) return null; // round the the computed point if needed\n\n      return rounder.round(pt.x, pt.y);\n    }\n    /**\n     * Split the given segment into multiple segments on the given points.\n     *  * Each existing segment will retain its leftSE and a new rightSE will be\n     *    generated for it.\n     *  * A new segment will be generated which will adopt the original segment's\n     *    rightSE, and a new leftSE will be generated for it.\n     *  * If there are more than two points given to split on, new segments\n     *    in the middle will be generated with new leftSE and rightSE's.\n     *  * An array of the newly generated SweepEvents will be returned.\n     *\n     * Warning: input array of points is modified\n     */\n\n  }, {\n    key: \"split\",\n    value: function split(point) {\n      var newEvents = [];\n      var alreadyLinked = point.events !== undefined;\n      var newLeftSE = new SweepEvent(point, true);\n      var newRightSE = new SweepEvent(point, false);\n      var oldRightSE = this.rightSE;\n      this.replaceRightSE(newRightSE);\n      newEvents.push(newRightSE);\n      newEvents.push(newLeftSE);\n      var newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice()); // when splitting a nearly vertical downward-facing segment,\n      // sometimes one of the resulting new segments is vertical, in which\n      // case its left and right events may need to be swapped\n\n      if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n        newSeg.swapEvents();\n      }\n\n      if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n        this.swapEvents();\n      } // in the point we just used to create new sweep events with was already\n      // linked to other events, we need to check if either of the affected\n      // segments should be consumed\n\n\n      if (alreadyLinked) {\n        newLeftSE.checkForConsuming();\n        newRightSE.checkForConsuming();\n      }\n\n      return newEvents;\n    }\n    /* Swap which event is left and right */\n\n  }, {\n    key: \"swapEvents\",\n    value: function swapEvents() {\n      var tmpEvt = this.rightSE;\n      this.rightSE = this.leftSE;\n      this.leftSE = tmpEvt;\n      this.leftSE.isLeft = true;\n      this.rightSE.isLeft = false;\n\n      for (var i = 0, iMax = this.windings.length; i < iMax; i++) {\n        this.windings[i] *= -1;\n      }\n    }\n    /* Consume another segment. We take their rings under our wing\n     * and mark them as consumed. Use for perfectly overlapping segments */\n\n  }, {\n    key: \"consume\",\n    value: function consume(other) {\n      var consumer = this;\n      var consumee = other;\n\n      while (consumer.consumedBy) {\n        consumer = consumer.consumedBy;\n      }\n\n      while (consumee.consumedBy) {\n        consumee = consumee.consumedBy;\n      }\n\n      var cmp = Segment.compare(consumer, consumee);\n      if (cmp === 0) return; // already consumed\n      // the winner of the consumption is the earlier segment\n      // according to sweep line ordering\n\n      if (cmp > 0) {\n        var tmp = consumer;\n        consumer = consumee;\n        consumee = tmp;\n      } // make sure a segment doesn't consume it's prev\n\n\n      if (consumer.prev === consumee) {\n        var _tmp = consumer;\n        consumer = consumee;\n        consumee = _tmp;\n      }\n\n      for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n        var ring = consumee.rings[i];\n        var winding = consumee.windings[i];\n        var index = consumer.rings.indexOf(ring);\n\n        if (index === -1) {\n          consumer.rings.push(ring);\n          consumer.windings.push(winding);\n        } else consumer.windings[index] += winding;\n      }\n\n      consumee.rings = null;\n      consumee.windings = null;\n      consumee.consumedBy = consumer; // mark sweep events consumed as to maintain ordering in sweep event queue\n\n      consumee.leftSE.consumedBy = consumer.leftSE;\n      consumee.rightSE.consumedBy = consumer.rightSE;\n    }\n    /* The first segment previous segment chain that is in the result */\n\n  }, {\n    key: \"prevInResult\",\n    value: function prevInResult() {\n      if (this._prevInResult !== undefined) return this._prevInResult;\n      if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();\n      return this._prevInResult;\n    }\n  }, {\n    key: \"beforeState\",\n    value: function beforeState() {\n      if (this._beforeState !== undefined) return this._beforeState;\n      if (!this.prev) this._beforeState = {\n        rings: [],\n        windings: [],\n        multiPolys: []\n      };else {\n        var seg = this.prev.consumedBy || this.prev;\n        this._beforeState = seg.afterState();\n      }\n      return this._beforeState;\n    }\n  }, {\n    key: \"afterState\",\n    value: function afterState() {\n      if (this._afterState !== undefined) return this._afterState;\n      var beforeState = this.beforeState();\n      this._afterState = {\n        rings: beforeState.rings.slice(0),\n        windings: beforeState.windings.slice(0),\n        multiPolys: []\n      };\n      var ringsAfter = this._afterState.rings;\n      var windingsAfter = this._afterState.windings;\n      var mpsAfter = this._afterState.multiPolys; // calculate ringsAfter, windingsAfter\n\n      for (var i = 0, iMax = this.rings.length; i < iMax; i++) {\n        var ring = this.rings[i];\n        var winding = this.windings[i];\n        var index = ringsAfter.indexOf(ring);\n\n        if (index === -1) {\n          ringsAfter.push(ring);\n          windingsAfter.push(winding);\n        } else windingsAfter[index] += winding;\n      } // calcualte polysAfter\n\n\n      var polysAfter = [];\n      var polysExclude = [];\n\n      for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {\n        if (windingsAfter[_i] === 0) continue; // non-zero rule\n\n        var _ring = ringsAfter[_i];\n        var poly = _ring.poly;\n        if (polysExclude.indexOf(poly) !== -1) continue;\n        if (_ring.isExterior) polysAfter.push(poly);else {\n          if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);\n\n          var _index = polysAfter.indexOf(_ring.poly);\n\n          if (_index !== -1) polysAfter.splice(_index, 1);\n        }\n      } // calculate multiPolysAfter\n\n\n      for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {\n        var mp = polysAfter[_i2].multiPoly;\n        if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);\n      }\n\n      return this._afterState;\n    }\n    /* Is this segment part of the final result? */\n\n  }, {\n    key: \"isInResult\",\n    value: function isInResult() {\n      // if we've been consumed, we're not in the result\n      if (this.consumedBy) return false;\n      if (this._isInResult !== undefined) return this._isInResult;\n      var mpsBefore = this.beforeState().multiPolys;\n      var mpsAfter = this.afterState().multiPolys;\n\n      switch (operation.type) {\n        case 'union':\n          {\n            // UNION - included iff:\n            //  * On one side of us there is 0 poly interiors AND\n            //  * On the other side there is 1 or more.\n            var noBefores = mpsBefore.length === 0;\n            var noAfters = mpsAfter.length === 0;\n            this._isInResult = noBefores !== noAfters;\n            break;\n          }\n\n        case 'intersection':\n          {\n            // INTERSECTION - included iff:\n            //  * on one side of us all multipolys are rep. with poly interiors AND\n            //  * on the other side of us, not all multipolys are repsented\n            //    with poly interiors\n            var least;\n            var most;\n\n            if (mpsBefore.length < mpsAfter.length) {\n              least = mpsBefore.length;\n              most = mpsAfter.length;\n            } else {\n              least = mpsAfter.length;\n              most = mpsBefore.length;\n            }\n\n            this._isInResult = most === operation.numMultiPolys && least < most;\n            break;\n          }\n\n        case 'xor':\n          {\n            // XOR - included iff:\n            //  * the difference between the number of multipolys represented\n            //    with poly interiors on our two sides is an odd number\n            var diff = Math.abs(mpsBefore.length - mpsAfter.length);\n            this._isInResult = diff % 2 === 1;\n            break;\n          }\n\n        case 'difference':\n          {\n            // DIFFERENCE included iff:\n            //  * on exactly one side, we have just the subject\n            var isJustSubject = function isJustSubject(mps) {\n              return mps.length === 1 && mps[0].isSubject;\n            };\n\n            this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n            break;\n          }\n\n        default:\n          throw new Error(\"Unrecognized operation type found \".concat(operation.type));\n      }\n\n      return this._isInResult;\n    }\n  }], [{\n    key: \"fromRing\",\n    value: function fromRing(pt1, pt2, ring) {\n      var leftPt, rightPt, winding; // ordering the two points according to sweep line ordering\n\n      var cmpPts = SweepEvent.comparePoints(pt1, pt2);\n\n      if (cmpPts < 0) {\n        leftPt = pt1;\n        rightPt = pt2;\n        winding = 1;\n      } else if (cmpPts > 0) {\n        leftPt = pt2;\n        rightPt = pt1;\n        winding = -1;\n      } else throw new Error(\"Tried to create degenerate segment at [\".concat(pt1.x, \", \").concat(pt1.y, \"]\"));\n\n      var leftSE = new SweepEvent(leftPt, true);\n      var rightSE = new SweepEvent(rightPt, false);\n      return new Segment(leftSE, rightSE, [ring], [winding]);\n    }\n  }]);\n\n  return Segment;\n}();\n\nvar RingIn = /*#__PURE__*/function () {\n  function RingIn(geomRing, poly, isExterior) {\n    _classCallCheck(this, RingIn);\n\n    if (!Array.isArray(geomRing) || geomRing.length === 0) {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n    }\n\n    this.poly = poly;\n    this.isExterior = isExterior;\n    this.segments = [];\n\n    if (typeof geomRing[0][0] !== 'number' || typeof geomRing[0][1] !== 'number') {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n    }\n\n    var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);\n    this.bbox = {\n      ll: {\n        x: firstPoint.x,\n        y: firstPoint.y\n      },\n      ur: {\n        x: firstPoint.x,\n        y: firstPoint.y\n      }\n    };\n    var prevPoint = firstPoint;\n\n    for (var i = 1, iMax = geomRing.length; i < iMax; i++) {\n      if (typeof geomRing[i][0] !== 'number' || typeof geomRing[i][1] !== 'number') {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      var point = rounder.round(geomRing[i][0], geomRing[i][1]); // skip repeated points\n\n      if (point.x === prevPoint.x && point.y === prevPoint.y) continue;\n      this.segments.push(Segment.fromRing(prevPoint, point, this));\n      if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;\n      if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;\n      if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;\n      if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;\n      prevPoint = point;\n    } // add segment from last to first if last is not the same as first\n\n\n    if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {\n      this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));\n    }\n  }\n\n  _createClass(RingIn, [{\n    key: \"getSweepEvents\",\n    value: function getSweepEvents() {\n      var sweepEvents = [];\n\n      for (var i = 0, iMax = this.segments.length; i < iMax; i++) {\n        var segment = this.segments[i];\n        sweepEvents.push(segment.leftSE);\n        sweepEvents.push(segment.rightSE);\n      }\n\n      return sweepEvents;\n    }\n  }]);\n\n  return RingIn;\n}();\nvar PolyIn = /*#__PURE__*/function () {\n  function PolyIn(geomPoly, multiPoly) {\n    _classCallCheck(this, PolyIn);\n\n    if (!Array.isArray(geomPoly)) {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n    }\n\n    this.exteriorRing = new RingIn(geomPoly[0], this, true); // copy by value\n\n    this.bbox = {\n      ll: {\n        x: this.exteriorRing.bbox.ll.x,\n        y: this.exteriorRing.bbox.ll.y\n      },\n      ur: {\n        x: this.exteriorRing.bbox.ur.x,\n        y: this.exteriorRing.bbox.ur.y\n      }\n    };\n    this.interiorRings = [];\n\n    for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {\n      var ring = new RingIn(geomPoly[i], this, false);\n      if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;\n      if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;\n      if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;\n      if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;\n      this.interiorRings.push(ring);\n    }\n\n    this.multiPoly = multiPoly;\n  }\n\n  _createClass(PolyIn, [{\n    key: \"getSweepEvents\",\n    value: function getSweepEvents() {\n      var sweepEvents = this.exteriorRing.getSweepEvents();\n\n      for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n        var ringSweepEvents = this.interiorRings[i].getSweepEvents();\n\n        for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n          sweepEvents.push(ringSweepEvents[j]);\n        }\n      }\n\n      return sweepEvents;\n    }\n  }]);\n\n  return PolyIn;\n}();\nvar MultiPolyIn = /*#__PURE__*/function () {\n  function MultiPolyIn(geom, isSubject) {\n    _classCallCheck(this, MultiPolyIn);\n\n    if (!Array.isArray(geom)) {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n    }\n\n    try {\n      // if the input looks like a polygon, convert it to a multipolygon\n      if (typeof geom[0][0][0] === 'number') geom = [geom];\n    } catch (ex) {// The input is either malformed or has empty arrays.\n      // In either case, it will be handled later on.\n    }\n\n    this.polys = [];\n    this.bbox = {\n      ll: {\n        x: Number.POSITIVE_INFINITY,\n        y: Number.POSITIVE_INFINITY\n      },\n      ur: {\n        x: Number.NEGATIVE_INFINITY,\n        y: Number.NEGATIVE_INFINITY\n      }\n    };\n\n    for (var i = 0, iMax = geom.length; i < iMax; i++) {\n      var poly = new PolyIn(geom[i], this);\n      if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;\n      if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;\n      if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;\n      if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;\n      this.polys.push(poly);\n    }\n\n    this.isSubject = isSubject;\n  }\n\n  _createClass(MultiPolyIn, [{\n    key: \"getSweepEvents\",\n    value: function getSweepEvents() {\n      var sweepEvents = [];\n\n      for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n        var polySweepEvents = this.polys[i].getSweepEvents();\n\n        for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n          sweepEvents.push(polySweepEvents[j]);\n        }\n      }\n\n      return sweepEvents;\n    }\n  }]);\n\n  return MultiPolyIn;\n}();\n\nvar RingOut = /*#__PURE__*/function () {\n  _createClass(RingOut, null, [{\n    key: \"factory\",\n\n    /* Given the segments from the sweep line pass, compute & return a series\n     * of closed rings from all the segments marked to be part of the result */\n    value: function factory(allSegments) {\n      var ringsOut = [];\n\n      for (var i = 0, iMax = allSegments.length; i < iMax; i++) {\n        var segment = allSegments[i];\n        if (!segment.isInResult() || segment.ringOut) continue;\n        var prevEvent = null;\n        var event = segment.leftSE;\n        var nextEvent = segment.rightSE;\n        var events = [event];\n        var startingPoint = event.point;\n        var intersectionLEs = [];\n        /* Walk the chain of linked events to form a closed ring */\n\n        while (true) {\n          prevEvent = event;\n          event = nextEvent;\n          events.push(event);\n          /* Is the ring complete? */\n\n          if (event.point === startingPoint) break;\n\n          while (true) {\n            var availableLEs = event.getAvailableLinkedEvents();\n            /* Did we hit a dead end? This shouldn't happen. Indicates some earlier\n             * part of the algorithm malfunctioned... please file a bug report. */\n\n            if (availableLEs.length === 0) {\n              var firstPt = events[0].point;\n              var lastPt = events[events.length - 1].point;\n              throw new Error(\"Unable to complete output ring starting at [\".concat(firstPt.x, \",\") + \" \".concat(firstPt.y, \"]. Last matching segment found ends at\") + \" [\".concat(lastPt.x, \", \").concat(lastPt.y, \"].\"));\n            }\n            /* Only one way to go, so cotinue on the path */\n\n\n            if (availableLEs.length === 1) {\n              nextEvent = availableLEs[0].otherSE;\n              break;\n            }\n            /* We must have an intersection. Check for a completed loop */\n\n\n            var indexLE = null;\n\n            for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n              if (intersectionLEs[j].point === event.point) {\n                indexLE = j;\n                break;\n              }\n            }\n            /* Found a completed loop. Cut that off and make a ring */\n\n\n            if (indexLE !== null) {\n              var intersectionLE = intersectionLEs.splice(indexLE)[0];\n              var ringEvents = events.splice(intersectionLE.index);\n              ringEvents.unshift(ringEvents[0].otherSE);\n              ringsOut.push(new RingOut(ringEvents.reverse()));\n              continue;\n            }\n            /* register the intersection */\n\n\n            intersectionLEs.push({\n              index: events.length,\n              point: event.point\n            });\n            /* Choose the left-most option to continue the walk */\n\n            var comparator = event.getLeftmostComparator(prevEvent);\n            nextEvent = availableLEs.sort(comparator)[0].otherSE;\n            break;\n          }\n        }\n\n        ringsOut.push(new RingOut(events));\n      }\n\n      return ringsOut;\n    }\n  }]);\n\n  function RingOut(events) {\n    _classCallCheck(this, RingOut);\n\n    this.events = events;\n\n    for (var i = 0, iMax = events.length; i < iMax; i++) {\n      events[i].segment.ringOut = this;\n    }\n\n    this.poly = null;\n  }\n\n  _createClass(RingOut, [{\n    key: \"getGeom\",\n    value: function getGeom() {\n      // Remove superfluous points (ie extra points along a straight line),\n      var prevPt = this.events[0].point;\n      var points = [prevPt];\n\n      for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n        var _pt = this.events[i].point;\n        var _nextPt = this.events[i + 1].point;\n        if (compareVectorAngles(_pt, prevPt, _nextPt) === 0) continue;\n        points.push(_pt);\n        prevPt = _pt;\n      } // ring was all (within rounding error of angle calc) colinear points\n\n\n      if (points.length === 1) return null; // check if the starting point is necessary\n\n      var pt = points[0];\n      var nextPt = points[1];\n      if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();\n      points.push(points[0]);\n      var step = this.isExteriorRing() ? 1 : -1;\n      var iStart = this.isExteriorRing() ? 0 : points.length - 1;\n      var iEnd = this.isExteriorRing() ? points.length : -1;\n      var orderedPoints = [];\n\n      for (var _i = iStart; _i != iEnd; _i += step) {\n        orderedPoints.push([points[_i].x, points[_i].y]);\n      }\n\n      return orderedPoints;\n    }\n  }, {\n    key: \"isExteriorRing\",\n    value: function isExteriorRing() {\n      if (this._isExteriorRing === undefined) {\n        var enclosing = this.enclosingRing();\n        this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n      }\n\n      return this._isExteriorRing;\n    }\n  }, {\n    key: \"enclosingRing\",\n    value: function enclosingRing() {\n      if (this._enclosingRing === undefined) {\n        this._enclosingRing = this._calcEnclosingRing();\n      }\n\n      return this._enclosingRing;\n    }\n    /* Returns the ring that encloses this one, if any */\n\n  }, {\n    key: \"_calcEnclosingRing\",\n    value: function _calcEnclosingRing() {\n      // start with the ealier sweep line event so that the prevSeg\n      // chain doesn't lead us inside of a loop of ours\n      var leftMostEvt = this.events[0];\n\n      for (var i = 1, iMax = this.events.length; i < iMax; i++) {\n        var evt = this.events[i];\n        if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n      }\n\n      var prevSeg = leftMostEvt.segment.prevInResult();\n      var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n\n      while (true) {\n        // no segment found, thus no ring can enclose us\n        if (!prevSeg) return null; // no segments below prev segment found, thus the ring of the prev\n        // segment must loop back around and enclose us\n\n        if (!prevPrevSeg) return prevSeg.ringOut; // if the two segments are of different rings, the ring of the prev\n        // segment must either loop around us or the ring of the prev prev\n        // seg, which would make us and the ring of the prev peers\n\n        if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n          if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n            return prevSeg.ringOut;\n          } else return prevSeg.ringOut.enclosingRing();\n        } // two segments are from the same ring, so this was a penisula\n        // of that ring. iterate downward, keep searching\n\n\n        prevSeg = prevPrevSeg.prevInResult();\n        prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n      }\n    }\n  }]);\n\n  return RingOut;\n}();\nvar PolyOut = /*#__PURE__*/function () {\n  function PolyOut(exteriorRing) {\n    _classCallCheck(this, PolyOut);\n\n    this.exteriorRing = exteriorRing;\n    exteriorRing.poly = this;\n    this.interiorRings = [];\n  }\n\n  _createClass(PolyOut, [{\n    key: \"addInterior\",\n    value: function addInterior(ring) {\n      this.interiorRings.push(ring);\n      ring.poly = this;\n    }\n  }, {\n    key: \"getGeom\",\n    value: function getGeom() {\n      var geom = [this.exteriorRing.getGeom()]; // exterior ring was all (within rounding error of angle calc) colinear points\n\n      if (geom[0] === null) return null;\n\n      for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n        var ringGeom = this.interiorRings[i].getGeom(); // interior ring was all (within rounding error of angle calc) colinear points\n\n        if (ringGeom === null) continue;\n        geom.push(ringGeom);\n      }\n\n      return geom;\n    }\n  }]);\n\n  return PolyOut;\n}();\nvar MultiPolyOut = /*#__PURE__*/function () {\n  function MultiPolyOut(rings) {\n    _classCallCheck(this, MultiPolyOut);\n\n    this.rings = rings;\n    this.polys = this._composePolys(rings);\n  }\n\n  _createClass(MultiPolyOut, [{\n    key: \"getGeom\",\n    value: function getGeom() {\n      var geom = [];\n\n      for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n        var polyGeom = this.polys[i].getGeom(); // exterior ring was all (within rounding error of angle calc) colinear points\n\n        if (polyGeom === null) continue;\n        geom.push(polyGeom);\n      }\n\n      return geom;\n    }\n  }, {\n    key: \"_composePolys\",\n    value: function _composePolys(rings) {\n      var polys = [];\n\n      for (var i = 0, iMax = rings.length; i < iMax; i++) {\n        var ring = rings[i];\n        if (ring.poly) continue;\n        if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {\n          var enclosingRing = ring.enclosingRing();\n          if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));\n          enclosingRing.poly.addInterior(ring);\n        }\n      }\n\n      return polys;\n    }\n  }]);\n\n  return MultiPolyOut;\n}();\n\n/**\n * NOTE:  We must be careful not to change any segments while\n *        they are in the SplayTree. AFAIK, there's no way to tell\n *        the tree to rebalance itself - thus before splitting\n *        a segment that's in the tree, we remove it from the tree,\n *        do the split, then re-insert it. (Even though splitting a\n *        segment *shouldn't* change its correct position in the\n *        sweep line tree, the reality is because of rounding errors,\n *        it sometimes does.)\n */\n\nvar SweepLine = /*#__PURE__*/function () {\n  function SweepLine(queue) {\n    var comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;\n\n    _classCallCheck(this, SweepLine);\n\n    this.queue = queue;\n    this.tree = new SplayTree(comparator);\n    this.segments = [];\n  }\n\n  _createClass(SweepLine, [{\n    key: \"process\",\n    value: function process(event) {\n      var segment = event.segment;\n      var newEvents = []; // if we've already been consumed by another segment,\n      // clean up our body parts and get out\n\n      if (event.consumedBy) {\n        if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);\n        return newEvents;\n      }\n\n      var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);\n      if (!node) throw new Error(\"Unable to find segment #\".concat(segment.id, \" \") + \"[\".concat(segment.leftSE.point.x, \", \").concat(segment.leftSE.point.y, \"] -> \") + \"[\".concat(segment.rightSE.point.x, \", \").concat(segment.rightSE.point.y, \"] \") + 'in SweepLine tree. Please submit a bug report.');\n      var prevNode = node;\n      var nextNode = node;\n      var prevSeg = undefined;\n      var nextSeg = undefined; // skip consumed segments still in tree\n\n      while (prevSeg === undefined) {\n        prevNode = this.tree.prev(prevNode);\n        if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;\n      } // skip consumed segments still in tree\n\n\n      while (nextSeg === undefined) {\n        nextNode = this.tree.next(nextNode);\n        if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;\n      }\n\n      if (event.isLeft) {\n        // Check for intersections against the previous segment in the sweep line\n        var prevMySplitter = null;\n\n        if (prevSeg) {\n          var prevInter = prevSeg.getIntersection(segment);\n\n          if (prevInter !== null) {\n            if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;\n\n            if (!prevSeg.isAnEndpoint(prevInter)) {\n              var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);\n\n              for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n                newEvents.push(newEventsFromSplit[i]);\n              }\n            }\n          }\n        } // Check for intersections against the next segment in the sweep line\n\n\n        var nextMySplitter = null;\n\n        if (nextSeg) {\n          var nextInter = nextSeg.getIntersection(segment);\n\n          if (nextInter !== null) {\n            if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;\n\n            if (!nextSeg.isAnEndpoint(nextInter)) {\n              var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);\n\n              for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {\n                newEvents.push(_newEventsFromSplit[_i]);\n              }\n            }\n          }\n        } // For simplicity, even if we find more than one intersection we only\n        // spilt on the 'earliest' (sweep-line style) of the intersections.\n        // The other intersection will be handled in a future process().\n\n\n        if (prevMySplitter !== null || nextMySplitter !== null) {\n          var mySplitter = null;\n          if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {\n            var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);\n            mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;\n          } // Rounding errors can cause changes in ordering,\n          // so remove afected segments and right sweep events before splitting\n\n          this.queue.remove(segment.rightSE);\n          newEvents.push(segment.rightSE);\n\n          var _newEventsFromSplit2 = segment.split(mySplitter);\n\n          for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {\n            newEvents.push(_newEventsFromSplit2[_i2]);\n          }\n        }\n\n        if (newEvents.length > 0) {\n          // We found some intersections, so re-do the current event to\n          // make sure sweep line ordering is totally consistent for later\n          // use with the segment 'prev' pointers\n          this.tree.remove(segment);\n          newEvents.push(event);\n        } else {\n          // done with left event\n          this.segments.push(segment);\n          segment.prev = prevSeg;\n        }\n      } else {\n        // event.isRight\n        // since we're about to be removed from the sweep line, check for\n        // intersections between our previous and next segments\n        if (prevSeg && nextSeg) {\n          var inter = prevSeg.getIntersection(nextSeg);\n\n          if (inter !== null) {\n            if (!prevSeg.isAnEndpoint(inter)) {\n              var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);\n\n              for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {\n                newEvents.push(_newEventsFromSplit3[_i3]);\n              }\n            }\n\n            if (!nextSeg.isAnEndpoint(inter)) {\n              var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);\n\n              for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {\n                newEvents.push(_newEventsFromSplit4[_i4]);\n              }\n            }\n          }\n        }\n\n        this.tree.remove(segment);\n      }\n\n      return newEvents;\n    }\n    /* Safely split a segment that is currently in the datastructures\n     * IE - a segment other than the one that is currently being processed. */\n\n  }, {\n    key: \"_splitSafely\",\n    value: function _splitSafely(seg, pt) {\n      // Rounding errors can cause changes in ordering,\n      // so remove afected segments and right sweep events before splitting\n      // removeNode() doesn't work, so have re-find the seg\n      // https://github.com/w8r/splay-tree/pull/5\n      this.tree.remove(seg);\n      var rightSE = seg.rightSE;\n      this.queue.remove(rightSE);\n      var newEvents = seg.split(pt);\n      newEvents.push(rightSE); // splitting can trigger consumption\n\n      if (seg.consumedBy === undefined) this.tree.insert(seg);\n      return newEvents;\n    }\n  }]);\n\n  return SweepLine;\n}();\n\nvar POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;\nvar POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;\nvar Operation = /*#__PURE__*/function () {\n  function Operation() {\n    _classCallCheck(this, Operation);\n  }\n\n  _createClass(Operation, [{\n    key: \"run\",\n    value: function run(type, geom, moreGeoms) {\n      operation.type = type;\n      rounder.reset();\n      /* Convert inputs to MultiPoly objects */\n\n      var multipolys = [new MultiPolyIn(geom, true)];\n\n      for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n        multipolys.push(new MultiPolyIn(moreGeoms[i], false));\n      }\n\n      operation.numMultiPolys = multipolys.length;\n      /* BBox optimization for difference operation\n       * If the bbox of a multipolygon that's part of the clipping doesn't\n       * intersect the bbox of the subject at all, we can just drop that\n       * multiploygon. */\n\n      if (operation.type === 'difference') {\n        // in place removal\n        var subject = multipolys[0];\n        var _i = 1;\n\n        while (_i < multipolys.length) {\n          if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null) _i++;else multipolys.splice(_i, 1);\n        }\n      }\n      /* BBox optimization for intersection operation\n       * If we can find any pair of multipolygons whose bbox does not overlap,\n       * then the result will be empty. */\n\n\n      if (operation.type === 'intersection') {\n        // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,\n        //       it could be optimized to O(n * ln(n))\n        for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {\n          var mpA = multipolys[_i2];\n\n          for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {\n            if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];\n          }\n        }\n      }\n      /* Put segment endpoints in a priority queue */\n\n\n      var queue = new SplayTree(SweepEvent.compare);\n\n      for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {\n        var sweepEvents = multipolys[_i3].getSweepEvents();\n\n        for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {\n          queue.insert(sweepEvents[_j]);\n\n          if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            throw new Error('Infinite loop when putting segment endpoints in a priority queue ' + '(queue size too big). Please file a bug report.');\n          }\n        }\n      }\n      /* Pass the sweep line over those endpoints */\n\n\n      var sweepLine = new SweepLine(queue);\n      var prevQueueSize = queue.size;\n      var node = queue.pop();\n\n      while (node) {\n        var evt = node.key;\n\n        if (queue.size === prevQueueSize) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          var seg = evt.segment;\n          throw new Error(\"Unable to pop() \".concat(evt.isLeft ? 'left' : 'right', \" SweepEvent \") + \"[\".concat(evt.point.x, \", \").concat(evt.point.y, \"] from segment #\").concat(seg.id, \" \") + \"[\".concat(seg.leftSE.point.x, \", \").concat(seg.leftSE.point.y, \"] -> \") + \"[\".concat(seg.rightSE.point.x, \", \").concat(seg.rightSE.point.y, \"] from queue. \") + 'Please file a bug report.');\n        }\n\n        if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          throw new Error('Infinite loop when passing sweep line over endpoints ' + '(queue size too big). Please file a bug report.');\n        }\n\n        if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          throw new Error('Infinite loop when passing sweep line over endpoints ' + '(too many sweep line segments). Please file a bug report.');\n        }\n\n        var newEvents = sweepLine.process(evt);\n\n        for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {\n          var _evt = newEvents[_i4];\n          if (_evt.consumedBy === undefined) queue.insert(_evt);\n        }\n\n        prevQueueSize = queue.size;\n        node = queue.pop();\n      } // free some memory we don't need anymore\n\n\n      rounder.reset();\n      /* Collect and compile segments we're keeping into a multipolygon */\n\n      var ringsOut = RingOut.factory(sweepLine.segments);\n      var result = new MultiPolyOut(ringsOut);\n      return result.getGeom();\n    }\n  }]);\n\n  return Operation;\n}(); // singleton available by import\n\nvar operation = new Operation();\n\nvar union = function union(geom) {\n  for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    moreGeoms[_key - 1] = arguments[_key];\n  }\n\n  return operation.run('union', geom, moreGeoms);\n};\n\nvar intersection$1 = function intersection(geom) {\n  for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    moreGeoms[_key2 - 1] = arguments[_key2];\n  }\n\n  return operation.run('intersection', geom, moreGeoms);\n};\n\nvar xor = function xor(geom) {\n  for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    moreGeoms[_key3 - 1] = arguments[_key3];\n  }\n\n  return operation.run('xor', geom, moreGeoms);\n};\n\nvar difference = function difference(subjectGeom) {\n  for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    clippingGeoms[_key4 - 1] = arguments[_key4];\n  }\n\n  return operation.run('difference', subjectGeom, clippingGeoms);\n};\n\nvar index = {\n  union: union,\n  intersection: intersection$1,\n  xor: xor,\n  difference: difference\n};\n\nmodule.exports = index;\n", "(function() {\n\n  function parse(t, coordinatePrecision, extrasPrecision) {\n\n    function point(p) {\n      return p.map(function(e, index) {\n        if (index < 2) {\n            return 1 * e.toFixed(coordinatePrecision);\n        } else {\n            return 1 * e.toFixed(extrasPrecision);\n        }\n      });\n    }\n\n    function multi(l) {\n      return l.map(point);\n    }\n\n    function poly(p) {\n      return p.map(multi);\n    }\n\n    function multiPoly(m) {\n      return m.map(poly);\n    }\n\n    function geometry(obj) {\n      if (!obj) {\n        return {};\n      }\n      \n      switch (obj.type) {\n        case \"Point\":\n          obj.coordinates = point(obj.coordinates);\n          return obj;\n        case \"LineString\":\n        case \"MultiPoint\":\n          obj.coordinates = multi(obj.coordinates);\n          return obj;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          obj.coordinates = poly(obj.coordinates);\n          return obj;\n        case \"MultiPolygon\":\n          obj.coordinates = multiPoly(obj.coordinates);\n          return obj;\n        case \"GeometryCollection\":\n          obj.geometries = obj.geometries.map(geometry);\n          return obj;\n        default :\n          return {};\n      }\n    }\n\n    function feature(obj) {\n      obj.geometry = geometry(obj.geometry);\n      return obj\n    }\n\n    function featureCollection(f) {\n      f.features = f.features.map(feature);\n      return f;\n    }\n\n    function geometryCollection(g) {\n      g.geometries = g.geometries.map(geometry);\n      return g;\n    }\n\n    if (!t) {\n      return t;\n    }\n\n    switch (t.type) {\n      case \"Feature\":\n        return feature(t);\n      case \"GeometryCollection\" :\n        return geometryCollection(t);\n      case \"FeatureCollection\" :\n        return featureCollection(t);\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n      case \"MultiPoint\":\n      case \"MultiPolygon\":\n      case \"MultiLineString\":\n        return geometry(t);\n      default :\n        return t;\n    }\n      \n  }\n\n  module.exports = parse;\n  module.exports.parse = parse;\n\n}());\n  \n", "function isObject (obj) {\n  return typeof obj === 'object' && obj !== null\n}\n\nfunction forEach (obj, cb) {\n  if (Array.isArray(obj)) {\n    obj.forEach(cb)\n  } else if (isObject(obj)) {\n    Object.keys(obj).forEach(function (key) {\n      var val = obj[key]\n      cb(val, key)\n    })\n  }\n}\n\nfunction getTreeDepth (obj) {\n  var depth = 0\n\n  if (Array.isArray(obj) || isObject(obj)) {\n    forEach(obj, function (val) {\n      if (Array.isArray(val) || isObject(val)) {\n        var tmpDepth = getTreeDepth(val)\n        if (tmpDepth > depth) {\n          depth = tmpDepth\n        }\n      }\n    })\n\n    return depth + 1\n  }\n\n  return depth\n}\n\nfunction stringify (obj, options) {\n  options = options || {}\n  var indent = JSON.stringify([1], null, get(options, 'indent', 2)).slice(2, -3)\n  var addMargin = get(options, 'margins', false)\n  var addArrayMargin = get(options, 'arrayMargins', false)\n  var addObjectMargin = get(options, 'objectMargins', false)\n  var maxLength = (indent === '' ? Infinity : get(options, 'maxLength', 80))\n  var maxNesting = get(options, 'maxNesting', Infinity)\n\n  return (function _stringify (obj, currentIndent, reserved) {\n    if (obj && typeof obj.toJSON === 'function') {\n      obj = obj.toJSON()\n    }\n\n    var string = JSON.stringify(obj)\n\n    if (string === undefined) {\n      return string\n    }\n\n    var length = maxLength - currentIndent.length - reserved\n\n    var treeDepth = getTreeDepth(obj)\n    if (treeDepth <= maxNesting && string.length <= length) {\n      var prettified = prettify(string, {\n        addMargin: addMargin,\n        addArrayMargin: addArrayMargin,\n        addObjectMargin: addObjectMargin\n      })\n      if (prettified.length <= length) {\n        return prettified\n      }\n    }\n\n    if (isObject(obj)) {\n      var nextIndent = currentIndent + indent\n      var items = []\n      var delimiters\n      var comma = function (array, index) {\n        return (index === array.length - 1 ? 0 : 1)\n      }\n\n      if (Array.isArray(obj)) {\n        for (var index = 0; index < obj.length; index++) {\n          items.push(\n            _stringify(obj[index], nextIndent, comma(obj, index)) || 'null'\n          )\n        }\n        delimiters = '[]'\n      } else {\n        Object.keys(obj).forEach(function (key, index, array) {\n          var keyPart = JSON.stringify(key) + ': '\n          var value = _stringify(obj[key], nextIndent,\n                                 keyPart.length + comma(array, index))\n          if (value !== undefined) {\n            items.push(keyPart + value)\n          }\n        })\n        delimiters = '{}'\n      }\n\n      if (items.length > 0) {\n        return [\n          delimiters[0],\n          indent + items.join(',\\n' + nextIndent),\n          delimiters[1]\n        ].join('\\n' + currentIndent)\n      }\n    }\n\n    return string\n  }(obj, '', 0))\n}\n\n// Note: This regex matches even invalid JSON strings, but since we\u2019re\n// working on the output of `JSON.stringify` we know that only valid strings\n// are present (unless the user supplied a weird `options.indent` but in\n// that case we don\u2019t care since the output would be invalid anyway).\nvar stringOrChar = /(\"(?:[^\\\\\"]|\\\\.)*\")|[:,\\][}{]/g\n\nfunction prettify (string, options) {\n  options = options || {}\n\n  var tokens = {\n    '{': '{',\n    '}': '}',\n    '[': '[',\n    ']': ']',\n    ',': ', ',\n    ':': ': '\n  }\n\n  if (options.addMargin || options.addObjectMargin) {\n    tokens['{'] = '{ '\n    tokens['}'] = ' }'\n  }\n\n  if (options.addMargin || options.addArrayMargin) {\n    tokens['['] = '[ '\n    tokens[']'] = ' ]'\n  }\n\n  return string.replace(stringOrChar, function (match, string) {\n    return string ? match : tokens[match]\n  })\n}\n\nfunction get (options, name, defaultValue) {\n  return (name in options ? options[name] : defaultValue)\n}\n\nmodule.exports = stringify\n", "import * as CountryCoder from '@ideditor/country-coder';\n\nimport calcArea from '@mapbox/geojson-area';\nimport circleToPolygon  from 'circle-to-polygon';\nimport polygonClipping from 'polygon-clipping';\nimport precision  from 'geojson-precision';\nimport prettyStringify from '@aitodotai/json-stringify-pretty-compact';\n\n\nexport class LocationConflation {\n\n  // constructor\n  //\n  // `fc`  Optional FeatureCollection of known features\n  //\n  // Optionally pass a GeoJSON FeatureCollection of known features which we can refer to later.\n  // Each feature must have a filename-like `id`, for example: `something.geojson`\n  //\n  // {\n  //   \"type\": \"FeatureCollection\"\n  //   \"features\": [\n  //     {\n  //       \"type\": \"Feature\",\n  //       \"id\": \"philly_metro.geojson\",\n  //       \"properties\": { \u2026 },\n  //       \"geometry\": { \u2026 }\n  //     }\n  //   ]\n  // }\n  constructor(fc) {\n    // The _cache retains resolved features, so if you ask for the same thing multiple times\n    // we don't repeat the expensive resolving/clipping operations.\n    //\n    // Each feature has a stable identifier that is used as the cache key.\n    // The identifiers look like:\n    // - for point locations, the stringified point:          e.g. '[8.67039,49.41882]'\n    // - for geojson locations, the geojson id:               e.g. 'de-hamburg.geojson'\n    // - for countrycoder locations, feature.id property:     e.g. 'Q2'  (countrycoder uses Wikidata identifiers)\n    // - for aggregated locationSets, +[include]-[exclude]:   e.g '+[Q2]-[Q18,Q27611]'\n    this._cache = {};\n\n    // When strict mode = true, throw on invalid locations or locationSets.\n    // When strict mode = false, return `null` for invalid locations or locationSets.\n    this._strict = true;\n\n    // process input FeatureCollection\n    if (fc && fc.type === 'FeatureCollection' && Array.isArray(fc.features)) {\n      fc.features.forEach(feature => {\n        feature.properties = feature.properties || {};\n        let props = feature.properties;\n\n        // Get `id` from either `id` or `properties`\n        let id = feature.id || props.id;\n        if (!id || !/^\\S+\\.geojson$/i.test(id)) return;\n\n        // Ensure `id` exists and is lowercase\n        id = id.toLowerCase();\n        feature.id = id;\n        props.id = id;\n\n        // Ensure `area` property exists\n        if (!props.area) {\n          const area = calcArea.geometry(feature.geometry) / 1e6;  // m\u00B2 to km\u00B2\n          props.area = Number(area.toFixed(2));\n        }\n\n        this._cache[id] = feature;\n      });\n    }\n\n    // Replace CountryCoder world geometry to be a polygon covering the world.\n    let world = _cloneDeep(CountryCoder.feature('Q2'));\n    world.geometry = {\n      type: 'Polygon',\n      coordinates: [[[-180, -90], [180, -90], [180, 90], [-180, 90], [-180, -90]]]\n    };\n    world.id = 'Q2';\n    world.properties.id = 'Q2';\n    world.properties.area = calcArea.geometry(world.geometry) / 1e6;  // m\u00B2 to km\u00B2\n    this._cache.Q2 = world;\n  }\n\n\n  // validateLocation\n  // `location`  The location to validate\n  //\n  // Pass a `location` value to validate\n  //\n  // Returns a result like:\n  //   {\n  //     type:     'point', 'geojson', or 'countrycoder'\n  //     location:  the queried location\n  //     id:        the stable identifier for the feature\n  //   }\n  // or `null` if the location is invalid\n  //\n  validateLocation(location) {\n    if (Array.isArray(location) && (location.length === 2 || location.length === 3)) {   // [lon, lat] or [lon, lat, radius] point?\n      const lon = location[0];\n      const lat = location[1];\n      const radius = location[2];\n      if (\n        Number.isFinite(lon) && lon >= -180 && lon <= 180 &&\n        Number.isFinite(lat) && lat >= -90 && lat <= 90 &&\n        (location.length === 2 || (Number.isFinite(radius) && radius > 0))\n      ) {\n        const id = '[' + location.toString() + ']';\n        return { type: 'point', location: location, id: id };\n      }\n\n    } else if (typeof location === 'string' && /^\\S+\\.geojson$/i.test(location)) {   // a .geojson filename?\n      const id = location.toLowerCase();\n      if (this._cache[id]) {\n        return { type: 'geojson', location: location, id: id };\n      }\n\n    } else if (typeof location === 'string' || typeof location === 'number') {   // a country-coder value?\n      const feature = CountryCoder.feature(location);\n      if (feature) {\n        // Use wikidata QID as the identifier, since that seems to be the one\n        // property that everything in CountryCoder is guaranteed to have.\n        const id = feature.properties.wikidata;\n        return { type: 'countrycoder', location: location, id: id };\n      }\n    }\n\n    if (this._strict) {\n      throw new Error(`validateLocation:  Invalid location: \"${location}\".`);\n    } else {\n      return null;\n    }\n  }\n\n\n  // resolveLocation\n  // `location`  The location to resolve\n  //\n  // Pass a `location` value to resolve\n  //\n  // Returns a result like:\n  //   {\n  //     type:      'point', 'geojson', or 'countrycoder'\n  //     location:  the queried location\n  //     id:        a stable identifier for the feature\n  //     feature:   the resolved GeoJSON feature\n  //   }\n  //  or `null` if the location is invalid\n  //\n  resolveLocation(location) {\n    const valid = this.validateLocation(location);\n    if (!valid) return null;\n\n    const id = valid.id;\n\n    // Return a result from cache if we can\n    if (this._cache[id]) {\n      return Object.assign(valid, { feature: this._cache[id] });\n    }\n\n    // A [lon,lat] coordinate pair?\n    if (valid.type === 'point') {\n      const lon = location[0];\n      const lat = location[1];\n      const radius = location[2] || 25;   // km\n      const EDGES = 10;\n      const PRECISION = 3;\n      const area = Math.PI * radius * radius;\n      const feature = this._cache[id] = precision({\n        type: 'Feature',\n        id: id,\n        properties: { id: id, area: Number(area.toFixed(2)) },\n        geometry: circleToPolygon([lon, lat], radius * 1000, EDGES)  // km to m\n      }, PRECISION);\n      return Object.assign(valid, { feature: feature });\n\n    // A .geojson filename?\n    } else if (valid.type === 'geojson') {\n      // nothing to do here - these are all in _cache and would have returned already\n\n    // A country-coder identifier?\n    } else if (valid.type === 'countrycoder') {\n      let feature = _cloneDeep(CountryCoder.feature(id));\n      let props = feature.properties;\n\n      // -> This block of code is weird and requires some explanation. <-\n      // CountryCoder includes higher level features which are made up of members.\n      // These features don't have their own geometry, but CountryCoder provides an\n      //   `aggregateFeature` method to combine these members into a MultiPolygon.\n      // In the past, Turf/JSTS/martinez could not handle the aggregated features,\n      //   so we'd iteratively union them all together.  (this was slow)\n      // But now mfogel/polygon-clipping handles these MultiPolygons like a boss.\n      // This approach also has the benefit of removing all the internal boaders and\n      //   simplifying the regional polygons a lot.\n      if (Array.isArray(props.members)) {\n        let aggregate = CountryCoder.aggregateFeature(id);\n        aggregate.geometry.coordinates = _clip([aggregate], 'UNION').geometry.coordinates;\n        feature.geometry = aggregate.geometry;\n      }\n\n      // Ensure `area` property exists\n      if (!props.area) {\n        const area = calcArea.geometry(feature.geometry) / 1e6;  // m\u00B2 to km\u00B2\n        props.area = Number(area.toFixed(2));\n      }\n\n      // Ensure `id` property exists\n      feature.id = id;\n      props.id = id;\n\n      this._cache[id] = feature;\n      return Object.assign(valid, { feature: feature });\n    }\n\n    if (this._strict) {\n      throw new Error(`resolveLocation:  Couldn't resolve location \"${location}\".`);\n    } else {\n      return null;\n    }\n  }\n\n\n  // validateLocationSet\n  // `locationSet`  the locationSet to validate\n  //\n  // Pass a locationSet Object to validate like:\n  //   {\n  //     include: [ Array of locations ],\n  //     exclude: [ Array of locations ]\n  //   }\n  //\n  // Returns a result like:\n  //   {\n  //     type:         'locationset'\n  //     locationSet:  the queried locationSet\n  //     id:           the stable identifier for the feature\n  //   }\n  // or `null` if the locationSet is invalid\n  //\n  validateLocationSet(locationSet) {\n    locationSet = locationSet || {};\n    const validator = this.validateLocation.bind(this);\n    let include = (locationSet.include || []).map(validator).filter(Boolean);\n    let exclude = (locationSet.exclude || []).map(validator).filter(Boolean);\n\n    if (!include.length) {\n      if (this._strict) {\n        throw new Error(`validateLocationSet:  LocationSet includes nothing.`);\n      } else {\n        // non-strict mode, replace an empty locationSet with one that includes \"the world\"\n        locationSet.include = ['Q2'];\n        include = [{ type: 'countrycoder', location: 'Q2', id: 'Q2' }];\n      }\n    }\n\n    // Generate stable identifier\n    include.sort(_sortLocations);\n    let id = '+[' + include.map(d => d.id).join(',') + ']';\n    if (exclude.length) {\n      exclude.sort(_sortLocations);\n      id += '-[' + exclude.map(d => d.id).join(',') + ']';\n    }\n\n    return { type: 'locationset', locationSet: locationSet, id: id };\n  }\n\n\n  // resolveLocationSet\n  // `locationSet`  the locationSet to resolve\n  //\n  // Pass a locationSet Object to validate like:\n  //   {\n  //     include: [ Array of locations ],\n  //     exclude: [ Array of locations ]\n  //   }\n  //\n  // Returns a result like:\n  //   {\n  //     type:         'locationset'\n  //     locationSet:  the queried locationSet\n  //     id:           the stable identifier for the feature\n  //     feature:      the resolved GeoJSON feature\n  //   }\n  // or `null` if the locationSet is invalid\n  //\n  resolveLocationSet(locationSet) {\n    locationSet = locationSet || {};\n    const valid = this.validateLocationSet(locationSet);\n    if (!valid) return null;\n\n    const id = valid.id;\n\n    // Return a result from cache if we can\n    if (this._cache[id]) {\n      return Object.assign(valid, { feature: this._cache[id] });\n    }\n\n    const resolver = this.resolveLocation.bind(this);\n    const includes = (locationSet.include || []).map(resolver).filter(Boolean);\n    const excludes = (locationSet.exclude || []).map(resolver).filter(Boolean);\n\n    // Return quickly if it's a single included location..\n    if (includes.length === 1 && excludes.length === 0) {\n      return Object.assign(valid, { feature: includes[0].feature });\n    }\n\n    // Calculate unions\n    const includeGeoJSON = _clip(includes.map(d => d.feature), 'UNION');\n    const excludeGeoJSON = _clip(excludes.map(d => d.feature), 'UNION');\n\n    // Calculate difference, update `area` and return result\n    let resultGeoJSON = excludeGeoJSON ? _clip([includeGeoJSON, excludeGeoJSON], 'DIFFERENCE') : includeGeoJSON;\n    const area = calcArea.geometry(resultGeoJSON.geometry) / 1e6;  // m\u00B2 to km\u00B2\n    resultGeoJSON.id = id;\n    resultGeoJSON.properties = { id: id, area: Number(area.toFixed(2)) };\n\n    this._cache[id] = resultGeoJSON;\n    return Object.assign(valid, { feature: resultGeoJSON });\n  }\n\n\n  // strict\n  //\n  strict(val) {\n    if (val === undefined) {   // get\n      return this._strict;\n    } else {                   // set\n      this._strict = val;\n      return this;\n    }\n  }\n\n\n  // cache\n  // convenience method to access the internal cache\n  cache() {\n    return this._cache;\n  }\n\n\n  // stringify\n  // convenience method to prettyStringify the given object\n  stringify(obj, options) {\n    return prettyStringify(obj, options);\n  }\n}\n\n\n// Wrap the mfogel/polygon-clipping library and return a GeoJSON feature.\nfunction _clip(features, which) {\n  if (!Array.isArray(features) || !features.length) return null;\n\n  const fn = { UNION: polygonClipping.union, DIFFERENCE: polygonClipping.difference }[which];\n  const args = features.map(feature => feature.geometry.coordinates);\n  const coords = fn.apply(null, args);\n  return {\n    type: 'Feature',\n    properties: {},\n    geometry: {\n      type: whichType(coords),\n      coordinates: coords\n    }\n  };\n\n  // is this a Polygon or a MultiPolygon?\n  function whichType(coords) {\n    const a = Array.isArray(coords);\n    const b = a && Array.isArray(coords[0]);\n    const c = b && Array.isArray(coords[0][0]);\n    const d = c && Array.isArray(coords[0][0][0]);\n    return d ? 'MultiPolygon' : 'Polygon';\n  }\n}\n\n\nfunction _cloneDeep(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\n\n// Sorting the location lists is ok because they end up unioned together.\n// This sorting makes it possible to generate a deterministic id.\nfunction _sortLocations(a, b) {\n  const rank = { countrycoder: 1, geojson: 2, point: 3 };\n  const aRank = rank[a.type];\n  const bRank = rank[b.type];\n\n  return (aRank > bRank) ? 1\n    : (aRank < bRank) ? -1\n    : a.id.localeCompare(b.id);\n}\n"],
  "mappings": "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",
  "names": []
}
